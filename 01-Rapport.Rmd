---
header-includes: \usepackage{hyperref} \usepackage{booktabs} \hypersetup{ colorlinks=true,
  linkcolor=blue, filecolor=magenta, urlcolor=cyan}
bibliography: biblio.bib
bibliographystyle: apalike
nocite: | 
  @*
output:
  pdf_document: default
  html_document:
    df_print: paged
---
\newpage
\begin{flushright}
    \textbf{Équipe 8}
\end{flushright}

\begin{center}
    \vspace{2\baselineskip}
    Charles Comeau \\
    (111 185 421) \\
    \vspace{1\baselineskip}
    Nicholas Langevin \\
    (111 184 631) \\
    \vspace{1\baselineskip}
    Andréanne Larouche \\
    (111 190 518) \\
    \vspace{7\baselineskip}
    Apprentissage statistique en actuariat\\
    ACT-3114 \\
    \vspace{7\baselineskip}
    {\large
    \textbf{Analyse des données de renouvellement d'assurance}} \\
    \vspace{8\baselineskip}
    présenté à \\
    Marie-Pier Côté \\
    \vspace{9\baselineskip}
    École d’actuariat \\
    Université Laval \\
    27 février 2020
\end{center}


\newpage

\tableofcontents
```{R, LoadingPackages, echo = FALSE, include = FALSE, warning = FALSE}
library(CASdatasets)
library(knitr)
library(tidyverse)
library(mice)
library(xtable)
library(reshape2)
library(VIM)
library(gridExtra)
library(grid)
library(lattice)
require(FactoMineR)
require(factoextra)
require(plotly)
library(cluster)
require(scale)
```

```{R, TraitementDesDonnees, echo = FALSE, include = FALSE, warning = FALSE}
data(eudirectlapse)
data.init <- eudirectlapse

## Changement dans les donnees
data <- data.init

# Changement des 0 et 1 de lapse en renouvellement et resignation
data$lapse <- as.factor(data$lapse)
levels(data$lapse) <- c("renouvellement", "resignation")

# Changment des valeurs unknown en NA des variables: 
# polholder_diffdriver, vehicl_garage et policy_caruse
data[data$polholder_diffdriver == "unknown", ]$polholder_diffdriver <- NA
data[data$vehicl_garage == "unknown", ]$vehicl_garage <- NA
data[data$policy_caruse == "unknown", ]$policy_caruse <- NA

# Reordonnement de la variable prem_freqperyear en facteur ordonnée (ordinal)
data$prem_freqperyear <- factor(data$prem_freqperyear, order = TRUE, levels = c("1 per year", "2 per year", "4 per year", "12 per year"))

# Regions
data$vehicl_region <- factor(data$vehicl_region, order = TRUE, levels = c("Reg1", "Reg2", "Reg3", "Reg4", "Reg5", "Reg6", "Reg7", "Reg8", "Reg9", "Reg10", "Reg11", "Reg12", "Reg13", "Reg14"))

# Creation d un nouvelle variable prem_index=prem_final/prem_last
data$prem_index <- data$prem_final / data$prem_last - 1

# Traitement de la variable vehicl_powerkw: regroupement en 4 groupe
#data$vehicl_powerkw_na <- data$vehicl_powerkw
#data[data$vehicl_powerkw_na == "125-300 kW", ]$vehicl_powerkw_na <- NA
data[data$vehicl_powerkw %in% c("150 kW","175 kW","200 kW","225 kW","250 kW","275 kW","300 kW"), ]$vehicl_powerkw <- "125-300 kW"
data <- droplevels(data)
data$vehicl_powerkw <- factor(data$vehicl_powerkw, order = TRUE, levels = c("25-50 kW", "75 kW", "100 kW", "125-300 kW"))
table(data$vehicl_powerkw)
```

```{R, FonctionPrintTable, echo = FALSE, include = FALSE, warning = FALSE}
print.tables <- function(dat, caption="", label="", align=rep("c", ncol(dat)+1), digits=3, ...){
  print(xtable(dat, digits = digits,
             caption=caption,
             label=label,
             align=align),
            include.rownames = FALSE, sanitize.text.function=function(x){x},
            caption.placement = "top", comment=FALSE, ...)
}
```

\newpage

# Introduction

Les données qui seront analysées dans ce rapport proviennent du jeu de données "eudirectlapse" du paquetage "CASdatasets" de R. Dans le but de modéliser le statut de renouvellement de polices d'assurance, représenté par la variable "lapse" dans ce cas-ci, il sera d'abord nécessaire de visualiser et de pré-traiter les données observées des 23 060 polices d'assurance. Il est à noter que la durée d'observation est de un an et que l'année visée et la compagnie demeurent inconnue. On pourra distinguer les statuts de renouvellement comme étant affiché à résigné ("Resignation"") ou à renouvellement ("Renouvellement") selon le cas approprié. 
Ce jeu de données est intéressant du fait qu'il permettera au fur de l'analyse de nous indiquer les variables types ayant un impact sur la décision de renouvellement de police des assurés d'une compagnie d'assurance X. En plus d'être un problème de nature actuarielle, le jeu de données choisi pourra nous permettre d'entammer une ouverture des réflexions possibles lorsque nous aurons à travailler dans une compagnie d'assurance. Étant trois personnes intéressés par l'assurance de dommages, ce problème nous semblait des plus appropriés et intéressant face à nos intérêts communs. Le nombre d'observations est également intéressant car il nous permettera de porter des conclusions précise avec assez de crédibilité sans toutefois être avoir à travailler avec un jeu de données inutilement trop volumineux. De plus, chaque variable explicative semble à prime à bord intéressante pour l'analyse et assez pertinente, ce que nous pourrons découvrir dans l'élaboration de ce travail pratique.


\newpage
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
# Analyse exploratoire des données

## Variable réponse
La variable lapse indique si l'assuré à renouveller ou non sa police lors du renouvellement. Il s'agit de la variable exogène. Initialement, le choix du client était indiqué par une variable binaire. Si le client désirait résigner sa police lapse prenait la valeur 1, autrement elle prenait la valeur 0. À des fins de simplification et pour que la visualisation en soit amiliorée pour la suite, nous avons converti la variable en variable catégorielle à deux niveaux. La variable prendra maintenant la valeur **`r levels(data$lapse)[2]`** si le client résigne sa police et de **`r levels(data$lapse)[1]`** s'il la renouvelle.

On constate qu'il y a `r nrow(data)` clients dont `r nrow(data[data$lapse == "renouvellement", ])` qui ont renouveller leur police d'assurance, ce qui représente une proportion de `r round(nrow(data[data$lapse == "renouvellement",])/nrow(data)*100, 2)`%. La variable réponse n'est donc pas symétrique et il sera important d'en tenir compte lors de la modélisation. L'analyse des variables explicatives contenus dans ce jeu de données nous permettera de mieux comprendre les causes de résignation et de créer des patrons pour ainsi arriver à bien modéliser la variable de renouvellement de police.

## Variables catégorielles nominales
  
**polholder_diffdriver**

Cette variable représente la différence de statut qui pourrait avoir entre le propriétaire de la police et le conducteur principal.

```{r tabl_statut, echo=FALSE, results='asis'}
l1 <- c(summary(data$polholder_diffdriver)[c("all drivers > 24")])

l2 <- c(summary(data$polholder_diffdriver)[c("commercial")])

l3 <- c(summary(data$polholder_diffdriver)[c("learner 17")])

l4 <- c(summary(data$polholder_diffdriver)[c("only partner")])

l5 <- c(summary(data$polholder_diffdriver)[c("same")])

l6 <- c(summary(data$polholder_diffdriver)[c("young drivers")])

l7 <- c(summary(data$polholder_diffdriver)[c("NA's")])

ligne_name <- c("Conducteurs agée de 24+","Commerciale","Conducteur apprenti de 17 ans","Partenaire de couple", "Utilisateur seul", "Jeunes utilisateurs", "Données manquantes")
dist <- round(as.vector(rbind(l1 , l2, l3, l4, l5, l6, l7)/nrow(data)), 4)

tableau_statut <- cbind(ligne_name ,rbind(l1 , l2, l3, l4, l5, l6, l7), scales::percent(dist, suffix =" \\%", accuracy = 0.01))

dat_frame_tab <- as.data.frame(tableau_statut)

colnames(dat_frame_tab) <- c("Statut", "Nombre d'observation", "Distribution")

print.tables(dat_frame_tab, hline.after=c(-1,0,7), digits=2, align = c("l", "l", "c", "r"),
             caption="Distribution de la différence de statut entre le conducteur et le détenteur de la police", label="tbl:statutdiff")
```

On constate que la plupart des voitures assurées est utilisée seulement par le détenteur de la police ou par l,assuré et son partenaire de couple puisque c'est deux cas représente `r round((summary(data$polholder_diffdriver)[c("only partner")] + summary(data$polholder_diffdriver)[c("same")])/nrow(data)*100, 2)`% des observations. Il y a un pourcentage non négligeable de `r round((summary(data$polholder_diffdriver)[c("young drivers")])/nrow(data)*100, 2)`% pour lequel le véhicules est partagé par de jeunes conducteurs alors qu'il y a `r summary(data$polholder_diffdriver)[c("all drivers > 24")]`% des cas ou le véhicule est plutôt partagé entre des personnes plus agées (24 ans et plus). À noté qu'il y a 12 observations pour lesquelles la variable est manquante. Cela sera traité dans la section traitement des valeurs manquantes. 

La variable **polholder_gender** représente le sexe du propriétaire de la police. Voici la répartition en pourcentage du sexe pour les propriétaires de police d'assurance.


```{r tabl_sexe, echo=FALSE, results='asis'}
p1 <- summary(data$polholder_gender)[c("Male")]
p2 <- summary(data$polholder_gender)[c("Female")]

ligne_name <- c("Homme", "Femme")
dist <- round(as.vector(rbind(p1, p2)/nrow(data)), 4)
tableau_sexe <- cbind(ligne_name ,rbind(p1 , p2), scales::percent(dist, suffix =" \\%", accuracy = 0.01))

dat_frame_tab <- as.data.frame(tableau_sexe)

colnames(dat_frame_tab) <- c("Sexe", "Nombre d'observation", "Distribution")

print.tables(dat_frame_tab, hline.after=c(-1,0,2), digits=2, 
             align = c("l", "l", "c", "r"),
             caption="Distribution du sexe du détenteur de police",
             label="tbl:polholderGender")
```

On voit qu'il y a significativement plus d'homme ayant une police d'assurance chez cet assureur que de femme. 

La variable **polholder_job** est, quant à elle, celle décrivant le travail du propriétaire du contrat. Deux valeurs sont possibles soit "medical" soit "normal". On constate que `r round((summary(data$polholder_job)[c("medical")])/nrow(data)*100, 2)`% des assurés on un travail de type médical alors qu'il y en a `r round((summary(data$polholder_job)[c("normal")])/nrow(data)*100, 2)`% qui ont un autre type d'emploi.

La variable **policy_caruse** représente les fins d'utilisation du véhicule. 

```{r tabl_caruse, echo=FALSE, results='asis', fig.cap="\\label{tbl:caruse}Usage du vehicule"}
l1 <- c(summary(data$policy_caruse)[c("commercial")])

l2 <- c(summary(data$policy_caruse)[c("private or freelance work")])

l3 <- c(summary(data$policy_caruse)[c("NA's")])

dist <- round(as.vector(rbind(l1, l2, l3)/nrow(data)), 4)
ligne_name <- c("Commerciale","Privé ou aller travailler","Données manquantes")
tableau_caruse <- cbind(ligne_name ,rbind(l1 , l2, l3), scales::percent(dist, suffix =" \\%", accuracy = 0.01))

dat_frame_tab3 <- as.data.frame(tableau_caruse)

colnames(dat_frame_tab3) <- c("Usage", "Nombre d'observation", "Distribution")

print.tables(dat_frame_tab3, digits=2, 
             align = c("l", "l", "c", "r"),
             caption="Distribution de l'utilisation du véhicule",
             label="tbl:policyCaruse")
```

On constate qu'il y a un nombre considérable de données manquantes et très peu de véhicule pour un usage commerciale.

De sont côté, la variable **vehicl_garage** décrit le type de stationnement de la voiture. Voici la répartition des types de stationnement.

```{r tabl_garage, echo=FALSE, results='asis', fig.cap="\\label{tbl:garage}Type de stationnement"}
l1 <- c(summary(data$vehicl_garage)[c("carport")])

l2 <- c(summary(data$vehicl_garage)[c("parking deck")])

l3 <- c(summary(data$vehicl_garage)[c("private estate")])

l4 <- c(summary(data$vehicl_garage)[c("private garage")])

l5 <- c(summary(data$vehicl_garage)[c("street")])

l6 <- c(summary(data$vehicl_garage)[c("underground garage")])

l7 <- c(summary(data$vehicl_garage)[c("other")])

l8 <- c(summary(data$vehicl_garage)[c("NA's")])

dist <- round(as.vector(rbind(l1, l2, l3, l4, l5, l6, l7, l8)/nrow(data)), 4)
ligne_name <- c("Sous un abri d'auto", "Terrase de stationnement", "Stationnement privé", "Garage", "Rue", "Garage sous-terrain", "Autre", "Données manquantes")
tableau_garage <- cbind(ligne_name ,rbind(l1 , l2, l3, l4, l5, l6, l7, l8), scales::percent(dist, suffix =" \\%", accuracy = 0.01))

dat_frame_tab4 <- as.data.frame(tableau_garage)

colnames(dat_frame_tab4) <- c("Moyen de stationnement", "Nombre d'observation", "Distribution")

print.tables(dat_frame_tab4, digits=2, 
             align = c("l", "l", "c", "r"),
             caption="Distribution du type de stationnement",
             label="tbl:policyGarage")
```

On voit que pour les moyens de stationnement les plus populaire sont le garage privé et la rue. Il y a des données manquantes, elles seront traitées plus loin dans le rapport.

La variable **polholder_BMCevol** indique si la prime de renouvellement à connue une hausse, une baisse ou est demeuré stable par rapport à la prime payée lors du dernier renouvellement.

TITRE : Distribution la variable polholder_BMCevol
```{r tabl_BM2, echo=FALSE, results='asis', fig.cap="\\label{tbl:BM}Bonus Malus"}
l1 <- c(summary(data$polholder_BMCevol)[c("up")])

l2 <- c(summary(data$polholder_BMCevol)[c("stable")])

l3 <- c(summary(data$polholder_BMCevol)[c("down")])

dist <- round(as.vector(rbind(l1, l2, l3)/nrow(data)), 4)
ligne_name <- c("Hausse", "Inchangée", "Baisse")
tableau_BM <- cbind(ligne_name ,rbind(l1 , l2, l3), scales::percent(dist, suffix =" \\%", accuracy = 0.01))

dat_frame_tab5 <- as.data.frame(tableau_BM)

colnames(dat_frame_tab5) <- c("Prime de renouvellement", "Nombre d'observation", "Distribution")

print.tables(dat_frame_tab5, digits=2, 
             align = c("l", "l", "c", "r"),
             caption="Distribution de l'indice Bonus-Malus",
             label="tbl:policyBM")
```

On constate que la plupart des contrats sont demeurés stables ou ont connus des baisses au niveau des primes.

La variable **vehicl_region** représente la région habitée par le détenteur de la police et plus particulièrement une région faisant partie de l'union européenne. Il y a 14 régions et elles sont numérotés mais nous savons pas à quel emplacement géographique cela correspond. La figure 1 suivante permet de visualiser la disperssion des contrats dans les diverse régions. Il est ainsi possible d'observer que certaines régions sont prédominantes comme la région 4, 7 et 8 par exemple.

```{r graph_vehicl_region, echo=FALSE, fig.width=5, fig.asp=.62, fig.align="center",fig.cap="\\label{fig:vehiclregion}Distribution des régions habités par les détenteurs de police, représenté par la variable \\textbf{vehicl\\_region}"}
ggplot(data, aes(x = vehicl_region))+
  geom_bar() +
  labs(x = "Région", y = "Fréquence") + 
  theme_bw() + theme(axis.text.x = element_text(angle = 20))
```



## Variables catégorielles ordinales

La variable catégorielle ordinale **prem_freqperyear** représente la fréquence par année à laquelle la prime est payable. Les fréquences possibles sont mensuelle, trimestrielle, semestrielle ou annuelle.

On voit qu'un peu moins de la moitié des clients paient la prime en un seul versement, environ un quart des clients paient trimestriellement, et le dernier quart est partagé par la prime payable semestriellement et mensuellement.

La variable **vehicl_powerkw** représente la puissance du moteur de la voiture conduit exprimé en chevaux moteurs. Initialement, cette variable contiennait 11 niveaux. Cependant, certains niveaux visait des valeurs fixes tandis que d'autres étaient défini à l'aide d'intervalle. Des doublons de niveaux figuraient par défaut dans la liste dû à certaines intervalles trop englobante. Afin d'uniformiser la mesure de cette variable, nous avons regroupé certains niveaux ensemble, soit tous les niveaux représentant une puissance de 125 à 300 chevaux moteurs. Cette modification a touché peut de cas était nécessaire pour l'obtention d'une interprétation adéquate des données. On peut d'ailleurs observé les proportions de chaque niveau avant et après modification dans les table 6 et 7.


```{r graph_prem_freqperyear, echo=FALSE, fig.width=5, fig.asp=.62, fig.align="center",fig.cap="\\label{fig:freqperyearAndvehiclGarage}todo"}
ggplot.premfreqperyear <- ggplot(data, aes(x = prem_freqperyear))+
  geom_bar() + theme_bw() + ggtitle("(1)") + theme(axis.text.x = element_text(angle = 90)) 
 

ggplot.vehicl_garage <- ggplot(data, aes(x = vehicl_garage))+
  geom_bar() + theme_bw() + ggtitle("(2)") + theme(axis.text.x = element_text(angle = 90)) 

grid.arrange(ggplot.premfreqperyear, ggplot.vehicl_garage,  ncol=2)
```


```{r tabl_powerkw, echo=FALSE, results='asis', fig.cap="\\label{tbl:powerkw}Tableaux de fréquence des catégories de puissance de moteur"}
c1_avant <- gsub(" kW", "", levels(data.init$vehicl_powerkw))
c2_avant <- unname(summary(data.init$vehicl_powerkw))
c3_avant <- round(as.numeric(c2_avant)/nrow(data), 4)
c3_avant <- scales::percent(c3_avant, suffix =" \\%", accuracy = 0.01)

c1_apres <- gsub(" kW", "", levels(data$vehicl_powerkw))
c2_apres <- unname(summary(data$vehicl_powerkw))
c3_apres <- round(as.numeric(c2_apres)/nrow(data), 4)
c3_apres <- scales::percent(c3_apres, suffix =" \\%", accuracy = 0.01)

tableau_powerkw_avant <- cbind(c1_avant, c2_avant, c3_avant)
tableau_powerkw_apres <- cbind(c1_apres, c2_apres, c3_apres)

tab_avant <- as.data.frame(tableau_powerkw_avant)
tab_apres <- as.data.frame(tableau_powerkw_apres)

colnames(tab_avant) <- c("Puissance (kW)", "Nombre d'observation", "Distribution")
colnames(tab_apres) <- c("Puissance (kW)", "Nombre d'observation","Distribution")



print.tables(rbind(tab_avant, tab_apres) , digits=2, 
             align = c("l", "l", "c", "r"),
             caption="Distribution de la puissance du moteur avant et après modification",
             label="",
             hline.after=c(-1,0,10, 15))
```

\newpage

## Variables numériques discrètes

La variable **polholder_age** est une variable numérique discrète représentant l'âge du propriétaire de la police d'assurance. La \autoref{fig:polholderAge} représente la distribution de âges des assurés.

```{r graph_polholder_age, echo=FALSE, fig.width=5, fig.asp=.62, fig.align="center",fig.cap="\\label{fig:polholderAge}Distribution de l'âge des détenteurs de polices dans la base de données, représenté par la variable \\textbf{polholder\\_age}"}
ggplot(data, aes(x = polholder_age))+
  geom_bar() +
  labs(x = "Âge du détenteur de police", y = "Fréquence") + 
  theme_bw() + facet_grid(~polholder_gender)
```

L'âge des détenteurs de police de cette compagnie d'assurance ce situe entre 19 et 85 ans inclusivement. On constate qu'il y a une forte proportion d'assuré entre 30 et 45 ans. La distribution est toutefois similaire que ce soit pour les hommes ou pour les femmes, en gardant en tête que les hommes sont présent en plus grand nombre. Il pourra être pertinent d'analyser dans la suite de ce travail pratique si les assurés de plus de 45 ans sont présent en moins grand nombre dû au fait que les primes sont trop élevé et compare davantage les primes entre les divers assureurs sur le marché avant de souscrire à une assurance auprès de cet assureur directement. 

Le nombre d'année sans résignation de la police d'assurance depuis la première année assurée est représenté par la variable umérique discrète **policy_age**. La \autoref{fig:policyAge} nous permet de constater que la plupart des assurés renouvelle leur police pour 3 années avant de résigné et une faible partie des assurés renouvelle pour plus de 3 années de suite.  Le maximum est observé à 17 ans.
```{r graph_policy_age, echo=FALSE, fig.width=5, fig.asp=.62, fig.align="center",fig.cap="\\label{fig:policyAge}Distribution de l'âge pour laquelle une police est en vigeur, représenter par la variable \\textbf{policy\\_age}"}
ggplot(data, aes(x = policy_age))+
  geom_bar() +
  labs(x = "Âge de la police", y = "Fréquence") + 
  theme_bw() 
```


En ce qui concerne la variable discrète **policy_nbcontract**, elle représente le nombre de contrat que l'assuré possède chez l'assureur. L'histogramme illustré à la \autoref{fig:policyNbcontract} fait resortir le fait qu'il y a une forte concentration d'assuré pour lesquels le nombre de contrat est inférieur à 5. On peut aussi voir que certains assurés ont jusqu'à un maximum de 15 contrats. 

```{r graph_policy_nbcontract, echo=FALSE, fig.width=5, fig.asp=.62, fig.align="center",fig.cap="\\label{fig:policyNbcontract}Distribution du nombre de contrats par police, représenter par la variable \\textbf{policy\\_nbcontract}"}
ggplot(data, aes(x = policy_nbcontract))+
  geom_bar() + 
  labs(x = "Nombre de contrat par police", y = "Fréquence") + 
  theme_bw() 
```


Les deux prochaines variables sont en lien avec l'aĝe du véhicule, il s'agit de variables numériques discrètes. La variable **vehicl_agepurchase** représente l'âge du véhicule lors de la transaction pour l'achat du véhicule. La variable **vehicl_age** représente, quant à elle, l'aĝe actuel du véhicule, soit dans ce cas l'âge actuel du véhicule au moment ou les données ont été prises. 

TITRE : distribution de l'âge des véhicules assurés au moment de l'achat du véhicule comparativement au moment de la prise de données.
```{r graph_age, echo=FALSE, fig.width=5, fig.asp=.62, fig.align="center",fig.cap="\\label{fig:}todo"}
agepurchase_vehicule <- ggplot(data, aes(x = vehicl_agepurchase))+
  geom_bar() + theme_bw() + ggtitle("(1)") + xlab("Âge à l'achat") + ylab("Fréquence")

age_vehicule <- ggplot(data, aes(x = vehicl_age))+
  geom_bar()+ theme_bw() + ggtitle("(2)") + xlab("Âge du véhicule") + ylab("Fréquence")


grid.arrange(agepurchase_vehicule, age_vehicule,  ncol=2)
```

Beaucoup de véhicules ont été achetés lorsqu'il était neuf, soit les valeurs indiquant 0 an. On remarque également qu'il y a peu de véhicule neuf lors du moment de la prise de données et que le nombre de véhicule est croissant en fonction de l'âge actuel jusqu'à 13 ans puis la tendance inverse est observé pour les âge supérieur à 13 ans. Étant donné qu'un véhicule âgé de 18 ans spécifiquement ne devrait raisonnablement pas être l'âge le plus fréquent, on conclut que cette valeur comprend 18 ans mais également tous les âges supérieurs.


## Variables numériques continues

Il y a plusieurs variables numériques continues relatives à la prime. La variable **prem_final** représente le montant de la prime proposé pour le renouvellement par l'assureur, la variable **prem_last** représente le montant payé lors du dernier renouvellement, la variable **prem_market** est la prime qui serait chargée selon le marché et la variable **prem_pure** représente la prime des coûts espérés. Le \autoref{tbl:summaryPrimes} montre leur distribution. 

Une prime seule peut difficilement expliquer pourquoi un assuré voudrait résigner sa police d'assurance car si sa prime est représentative de son risque réel, il n'aurait pas intérêt à changer d'assureur.
Par contre, si lors de son renouvellement, il voit sa prime grandement augmenter, il sera d'avantage sujet à vouloir changer d'assureur pour réduire ces coûts. 

```{r stats_prem, echo=FALSE, results='asis', fig.cap="\\label{tbl:summaryPrimes}Distribution des variables consernant les primes de l'assuré", warning=FALSE}
stats_final <- c(summary(data$prem_final)[c(1, 3, 4, 6)], sd(data$prem_final))

stats_last <- c(summary(data$prem_last)[c(1, 3, 4, 6)], sd(data$prem_last))

stats_market <- c(summary(data$prem_market)[c(1, 3, 4, 6)], sd(data$prem_market))

stats_pure <- c(summary(data$prem_pure)[c(1, 3, 4, 6)], sd(data$prem_pure))

prime_type <- c("Final","Last","Market","Pure", "Index (\\%)")
tableau_stats <- cbind(prime_type ,rbind(round(stats_final, 2), round(stats_last, 2), round(stats_market, 2), round(stats_pure, 2)))

dat_frame_tab <- as.data.frame(tableau_stats)

colnames(dat_frame_tab) <- c("Prime (\\$)", "Minimum", "Médiane", "Moyenne", "Maximum", "Écart-type")

print.tables(dat_frame_tab, digits=2, align = c("l", "l", rep("c",5)), caption = "Distribution des 4 types de primes")
```

Dans les représentations de la \autoref{fig:BoitesMoustache}, on observe que la distribution des variables **prem_last** et **prem_pure** ce rapproche de peu en ce qui concerne la moyenne et la variance des observations. Le variable **prem_final** diffère par sa variance plus élevée et la variable **prem_market** par sa moyenne qui est beaucoup plus faible. On remarque également, qu'en général, la variance reliée au détenteur de police de genre féminin est plus élevée ce qui s'explique par la proportion moins élevée de détenteur de police féminin. Pour les moyennes, elles sont semblables de ce côté, ce qui porte à croire que les primes ne sont pas influencées par le genre et c'est positif car ce serait un bais de stéréotype en cas contraire.

On remarque que les valeurs extrêmes ce situent d'avantage au niveau des détenteurs de police ayant renouvellé leur contrat, ce qui est contre intuitif. Cela porte à croire que ce sont de très mauvais risques et qu'ils restent assuré auprès de cette compagnie car une autre compagnie d'assurance ne pourrait pas leur offrir une meilleure prime. On peut valider que cette tendance n’est pas seulement reliée à la méthode de tarification de cette compagnie en comparant la distribution de **prem_last** et **prem_market** qui sont très similaire, ce qui indique que les primes chargés dans cette compagnie suivent le marché.

On peut également conclure que la prime en valeur absolue ne permet pas d’expliquer la raison pour laquelle un détenteur de police résignerait car une prime similaire lui serait chargée chez un autre assureur. Ce qui poussera réellement un assuré à rechercher un autre assureur, dans la grande majorité des cas, est sont pourcentage d’augmentation au renouvellement. C’est donc pour cette raison qu’une variable sera crée pour la suite du travail pratique pour arriver à la modélisation la plus adéquate possible. Elle sera nommée **prem_index** et sera égale à **prem_new** / **prem_last** - 1 .


```{r graph_primes, echo=FALSE, fig.width=10, fig.height= 30, fig.asp=.62, fig.align="center",fig.cap="\\label{fig:BoitesMoustache}Diagrammes en boite à moustache pour les différentes primes selon la variable réponse et le genre du détenteur de la police"}
 
prem_final <- ggplot(data, aes(y = prem_final, x = lapse, color = polholder_gender)) + geom_boxplot() + facet_grid() + theme_bw()

prem_last <- ggplot(data, aes(y = prem_last, x = lapse, color = polholder_gender)) + geom_boxplot() + facet_grid() + theme_bw()

prem_market <- ggplot(data, aes(y = prem_market, x = lapse, color = polholder_gender)) + geom_boxplot() + facet_grid() + theme_bw()

prem_pure <- ggplot(data, aes(y = prem_pure, x = lapse, color = polholder_gender)) + geom_boxplot() + facet_grid() + theme_bw()


grid.arrange(prem_final, prem_last, prem_market, prem_pure,  ncol=2, nrow = 2)
```

\newpage

# Traitement des valeurs manquantes
```{R, ProportionDeValeursManquante, echo = FALSE, results='asis'}
nb_manquant <- round(apply(data, 2, FUN = function(x) sum(is.na(x)))/nrow(data) * 100,2)
```
La base de données contenait seulement trois variables avec des valeurs manquantes. La variable indiquant la différence d'âge entre le détenteur de la police et le conducteur est manquante à `r nb_manquant[["polholder_diffdriver"]]`%, celle indiquant l'utilité du vehicule est manquante à `r nb_manquant[["policy_caruse"]]`% et la variable indiquant le type de garage où est entreposé le véhicule est manquante à `r nb_manquant[["vehicl_garage"]]`%. La \autoref{fig:missingPatern} montre le patron de non réponse. On remarque que la variable **polholder_diffdriver** semble avoir un patron de non réponse monotone avec les deux autres. Par contre, puisqu'il y a seulement 12 cas, nous n'allons pas tenir compte de ce lien lors de l'imputation des données. Pour ce qui est des variables **policy_caruse** et **vehicl_garage**, on remarque qu'il sont parfois manquante en même temps, mais seulement pour une minorité de cas.

```{R, MissingPattern, echo=FALSE, results="hide", fig.with=3, fig.height=3, fig.align="center", fig.cap="\\label{fig:missingPatern}Patron de non réponse"}
# pattern.matrix <- md.pattern(data, rotate.names = TRUE)
missing.pathern <- aggr(data, combined = TRUE, ylabs="",labels=c("","","","diffdriver","","","","caruse","","","","","","","","","garage","",""), sortVars=TRUE)
```

Premièrement, dans le but déterminer si les données manquantes sont MCAR, le test d'hypothese suivant a été effectué
\begin{align*}
  H_0:&\: \text{Le données sont MCAR} \\
  H_1:&\: \text{Le données ne sont pas MCAR}
\end{align*}
Pour conclure que les données sont MCAR, il est nécessaire d'accepter $H_0$ pour toutes les variables. Par contre, un seul refus de cette hypothèse nous permettera de conclure l'hypothèse alternative, c'est-à-dire que les données ne sont pas MCAR. Pour effectuer le test avec une variable catégorielle, il sera nécéssaire d'utiliser la statistique de khi-carré alors que pour une variable numérique, la statistique la student sera utilisée.

```{r TraitementDesValeursManquantes, echo=FALSE, results=FALSE, warning=FALSE}
test.MCAR <- function(var.data, na_var.data){
  # Détermine automatique si la variable est catégorielle ou
  # nuérique et utilise le bon test approprié.
  if(is.numeric(data[[var.data]])){
    round(t.test(data[[var.data]][is.na(data[[na_var.data]])],
                    data[[var.data]][!is.na(data[[na_var.data]])],var.equal=FALSE)[["p.value"]], 5) 
  }else{
    round(chisq.test(data[[var.data]], is.na(data[[na_var.data]]), correct=FALSE)[["p.value"]], 5)
  }
}
# Test pour vehicl_garage
sapply(names(data  %>% select(-vehicl_garage)), FUN=test.MCAR, na_var.data = "vehicl_garage")
# Test pour policy_caruse
sapply(names(data  %>% select(-policy_caruse)), FUN=test.MCAR, na_var.data = "policy_caruse")
# Test pour polholder_diffdriver
sapply(names(data  %>% select(-polholder_diffdriver, -vehicl_garage, -policy_caruse)), FUN=test.MCAR, na_var.data = "polholder_diffdriver")
```

En ce qui concerne les variables **vehicl_garage** et **policy_caruse**, plusieurs statistiques observés permettent de rejeter l'hypothèse nulle à un niveau significatif de $0.001%$. Par contre, dans le cas de **polholder_diffdriver**, seulement la variable **polholder_job** permet de rejeter $H_0$, c'est à dire que les données manquantes ne sont pas complètement aléatoire.

Il est à noter qu'il n'est pas possible de vérifier avec certitude si les données sont MAR ou NMAR. Cela est dû au fait que puisque les données proviennent d'un compagnie inconnue, nous n'avons pas d'information sur la méthode de récolte des données et il nous est impossible de trouver des patrons qui pourraient provoquer des données de type NMAR. En conséquence, nous considérerons que nos données sont MAR. De ce sens, en effectuant des tests khi-carré pour la variable **polholder_diffdriver**, il a été remarqué que l'information sur la différence entre le détenteur de police et le conducteur nous indique que les variables sont toujours manquantes dans le cas ou le travail du détenteur de la police est dans le domaine de la médecine. Ceci renforce l'idée que le patron de non réponse pour cette variable dépend des variables observés dans le jeux de données, soit que les données sont NMAR mais nous ne pouvons rien conclure de ce côté.

Pour l'imputation des données, la méthode d'imputation multiples a été choisie et donc utilisée. Pour des restrictions de temps de calcul, cinq itérations de régression stochastique ont été fait. Pour la variable **policy_caruse**, une régression logistique a été effectuée puisque la variable catégorielle comporte deux niveaux. Pour les variables **vehicl_garage** et **polholder_diffdriver**, qui sont des variables catégorielles non-ordonées, une régression polynomiale a été utilisée.

```{R, ImputationDesDonnees, echo = FALSE, eval=FALSE, warning = FALSE}
summary(data[,c("vehicl_garage", "policy_caruse", "polholder_diffdriver")])
# Choix des methode
methode <- c("sample","sample","polyreg","sample","sample","sample","logreg","sample","sample","sample","sample","sample","sample","sample","sample","polyreg","sample","sample", "sample")
donnees.imp <- mice(data %>% select(-lapse), m=1, method=methode, print=FALSE, seed=1095)
summary(donnees.imp)
data.compl <- mice::complete(donnees.imp)
data.compl <- cbind(data$lapse, data.compl)

# Summary apres semble similaire a avant
summary(data.compl[,c("vehicl_garage", "policy_caruse", "polholder_diffdriver")])
# Il ne reste bien plus de donnees.
apply(data.compl, 2, FUN = function(x) sum(is.na(x)))
```


\newpage

# Analyse en composantes principales
Étant donné que notre jeu de données contient `R nrow(Donnees_tempo)` observations, il peut être utile de visualiser les données à l'aide de l'analyse en composantes principales, appelé ACP. En effet, ce type d'analyse permet de mieux visualiser un jeu de données lorsque celui-ci est de grande dimension. Il sera ainsi possible de voir quelles variables explicatives sont plus intéressantes par leur impact sur la variance des composantes principales. Il est à noter qu'en général, on garde assez de composantes pour représenter entre 80 et 90 % de la variance totale. 

Pour que cette méthode de visualisation puisse être utilisée, il sera nécessaire de prendre seulement les variables explicatives numériques de ce jeu de donnée. Les variables catégorielles ne seront pas analysées dans cette section car même en les transformant en variables numériques, elles ne seront pas représentative des valeurs leur qui leur aurait été attribuée en faisant la modification de type.

```{R , echo = FALSE, include = TRUE}
data <- na.omit(data)
Data_num <- data[, c("polholder_age", "policy_age", "policy_nbcontract", "prem_final", "prem_last", "prem_market", 
                              "prem_pure", "vehicl_age", "vehicl_agepurchase")]
```

On doit ensuite choisir le nombre de composantes principales. Cette étape peut être complétée en ayant deja un pourcentage de variance expliquée en tête et en choisissant le nombre de composantes à partir des valeurs propres ou en analysant directement le diagramme d'ébouli. Dans ce cas, la méthode du coude ne sera pas utilisée, on priviligie d'avantage le choix selon le premier plateau observée. Le nombre de composantes choisit seront celle ne faisant pas partie du premier plateau observée. 

```{R , echo = FALSE, include = FALSE}
ACP <- PCA(Data_num, scale = TRUE)  
```

```{R , echo = FALSE, include = TRUE, fig.with=4, fig.height=4, fig.align="center", fig.cap="Diagramme d'éboulis représentant le pourcentage expliquer de la variance pour chaque dimention."}
fviz_screeplot(ACP)
```

Selon le diagramme d'éboulis, il sera nécessaire de conserver 2 composantes principales et on observe, à l'aide des valeurs propres de la matrice de corélation, que 2 composantes principales permettent d'expliquer 63% de la variance totale.

À l'aide du graphique ACP des variables, on peut voir la gravité des contributions pour chacune des variables sur chaque composantes principales retenu. Ainsi, on peut observer que pour la première composante principale, un score élevé indique un contrat ayant une prime élevée, que ce soit la prime du marché, la prime pure, la prime finale ou la prime chargée lors du dernier renouvellement. Par contre, un assuré âgé qui renouvelle depuis plusieurs année aura un score plus faible qu'un assuré en bas âge ayant une police d'assurance récente. Un score élevé représente donc un assuré en bas âge ayant une police récente et une prime élevé tandis qu'un score faible représente une personne plus âgée avec une faible prime d'assurance. 

La deuxième composante principale représente, quant à elle, l'âge du véhicule assuré. Un score élevé est associé à des véhicules de moindres valeurs mais risquant d'avantage un bris de veillesse. Plus les polices d'assurance sont récentes et plus le score en sera augmenté. Ainsi, les polices d'assurances récente ayant des véhicules de l'année représenteront les scores les plus faibles pour cette composante.

```{R , echo = FALSE, include = FALSE}
ACP$eig
ACP$var$contrib
```

En illustrant les contributions des variables pour les deux premières composantes principales, il est plus facile de visualiser les conclusions mentionnées précédemment.

```{R, message=FALSE, echo = FALSE, include = TRUE, fig.with=4, fig.height=4, fig.align="center", fig.cap="Représentation de la contribution de chaques variables numériques dans les deux premières dimentions résultant de l'analyse en composante principal."}
contrib <- data.frame(ACP$var$coord[,1:2])
contrib$carac <- rownames(contrib)
contrib.long <- reshape2::melt(contrib)

ggplot(contrib.long, aes(x=carac, fill=variable, y=value))+
  geom_bar(stat="identity",position=PositionDodge)+
  facet_grid(~variable)+
  theme(legend.position="top",axis.text.x = element_text(angle = 90))+
  xlab("Variable") +
  ylab("Poids") +
  coord_flip()
```

\newpage

# Partitionnement en k moyennes

Le partitionnement en k moyennes est utilisé pour classifier les observations en k groupes distincts. La valeur de k est une valeur qu'on transmet pour indiquer le nombre de partitions désirées. Chaque observation sera ensuite assigné à un seul groupe. L'algorithme utilisée pour ce type de partitionnement a pour objectif de minimiser la variance intra-groupe.

Le choix du nombre de groupe peut être choisit à l'aide de la méthode du coude. Ainsi en ce réferant au graphique suivant, on devrait faire le partitionnement sur 2 groupes distincts. On s'arrête la valeur de $k$ qui ce situe dans le "pli de coude", soit juste avant le dernier plateau du diagramme d'éboulis. Il est à noter que le nombre d'observations a été réduit pour pouvoir faire le diagramme d'éboulis. Notre jeu de données étant trop volumineux, ce qui engendrait des erreurs d'exécution. L'échantillion utilisé a été extrait aléatoirement et sans remise pour avoir une représentation adéquate et la moins biaisé possible.

```{R, echo = FALSE, include = TRUE, fig.with=4, fig.height=4, fig.align="center", fig.cap="Diagramme d'éboulis représentant l'erreur intra-groupes pour différent nombre de groupes."}
set.seed(123)
echantillon <- sample(nrow(Data_num), size = 8000, replace = FALSE) 

fviz_nbclust(Data_num[echantillon, ], kmeans, k.max=7, method = "wss")
```

En ayant en tête le nombre de groupe nécessaire pour la classification, on effectue le partitionnement et on obtient le graphique suivant :

```{R, echo = FALSE, include = TRUE, fig.with=4, fig.height=4, fig.align="center", fig.cap="Représentation des deux groupes formés par l'algorithme des $k$-moyenne dans le système d'axe des deux première dimention de l'analyse en composante principal."}
K <- 2
kmoyennes <- kmeans(Data_num, K, nstart=5)

Donnees_acp <- PCA(Data_num,  scale = FALSE, graph = FALSE)

composante1 <- Donnees_acp$ind$coord[,1]
composante2 <- Donnees_acp$ind$coord[,2]
groupe <- as.factor(kmoyennes$cluster)

ggplot() + 
  geom_point(aes(composante1, composante2, color = groupe)) + 
  theme_minimal()

```

De ce graphique, on peut conclure que le partionnement c'est fait sur la première composante principale. Les assurés représentant moins de risque ce retrouve dans le groupe 2 tandis que les assurés plus risqués ce retrouve dans le groupe 1. Ainsi, le montant des primes typiques seraient d'environ 300\$ ou moins pour le deuxième groupe et de plus de 300\$ 


\newpage

# Conclusion

Comme mentionné précédemment, le jeu de données analysé dans ce travail pratique provient du paquetage "CASdatasets". Nous avons choisi ce jeu de données dans le but de modéliser le statut de renouvellement de polices d'assurance pour une compagnie et une année d'observation inconnu. Les variables explicatives touchent les caractéristiques liées aux primes payés, à l'assuré visé par la police d'assurance et au véhicule assuré.

Le jeu de donnée de départ a nécessité un prétraitement. Dans cette étape, nous avons changer le type de la variable réponse "lapse" pour améliorer la visualisation pour la suite. Elle était à prime à bord de type binaire et nous avons changé le type pour une variable de type catégorielle nominale prenant les valeurs possibles "renouvellement" et "resignation". Nous avons également dû changer les valeurs de certaines variables de "unknown" à "NA" pour l’uniformité. Les doublons ont été retirés. La variable **prem_freqperyear** a été réordonnée pour suivre l’ordre logique et améliorer la visualisation. Un regroupement a, en dernier lieu, été nécessaire, comme expliqué dans l’analyse exploratoire, dans le but d’uniformiser les différents niveaux de la variable **vehicl_powerkw**. Pour ce qui est de l’analyse exploratoire des données, cette étape nous a permis de bien visualiser les distributions et les informations comprises dans chacune des variables. Nous avons ainsi pu vérifier si des données aberrantes nous avaient échappées lors des premières modifications apportées. Notre jeu de données est bien construit et nous permettra d’obtenir un modèle intéressant. En effet, puisque la variable réponse **lapse** est une variable catégorielle pour laquelle deux valeurs sont possibles, soit renouvellement ou résignation, il sera intéressant pour la suite de modéliser la probabilité qu'un assuré renouvelle ou résigne pour la prochaine année. Un modèle linéaire avec régression logistique nous sera grandement utile pour cette étape. La prédiction de la régression correspondra, dans ce cas, à la probabilité désirée. 


\newpage

# Bibliographie

::: {#refs}
:::

\newpage

# Annexe

Description du jeu de données soumis sur le forum :

Notre jeu de données représente le statut de renouvellement pour 23 060 polices d'assurance basées sur un an d'observation. Les données receuillies proviennent d'une compagnie d'assurance inconnue dont l'année d'observation est également inconnue.

