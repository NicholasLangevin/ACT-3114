---
header-includes: \usepackage[french]{babel} \usepackage{hyperref} \hypersetup{ colorlinks=true,
  linkcolor=blue, filecolor=magenta, urlcolor=cyan, }
output:
  pdf_document: default
  html_document:
    df_print: paged
---

\newpage
\begin{flushright}
    \textbf{Équipe 8}
\end{flushright}

\begin{center}
    \vspace{2\baselineskip}
    Charles Comeau \\
    (111 185 421) \\
    \vspace{1\baselineskip}
    Nicholas Langevin \\
    (111 184 631) \\
    \vspace{1\baselineskip}
    Andréanne Larouche \\
    (111 190 518) \\
    \vspace{7\baselineskip}
    Apprentissage statistique en actuariat\\
    ACT-3114 \\
    \vspace{7\baselineskip}
    {\large
    \textbf{Analyse des données de renouvellement d'assurance}} \\
    \vspace{8\baselineskip}
    présenté à \\
    Marie-Pier Côté \\
    \vspace{9\baselineskip}
    École d’actuariat \\
    Université Laval \\
    27 février 2020
\end{center}

\newpage

\tableofcontents
```{R, LoadingPackages, echo = FALSE, include = FALSE, warning = FALSE}
library(CASdatasets)
library(tidyverse)
library(mice)
library(xtable)
library(reshape2)
library(VIM)
library(gridExtra)
library(grid)
library(lattice)
require(FactoMineR)
require(factoextra)
require(plotly)
library(cluster)
```

```{R, TraitementDesDonnees, echo = FALSE, include = FALSE, warning = FALSE}
data(eudirectlapse)
data.init <- eudirectlapse

## Changement dans les donnees
data <- data.init

# Changement des 0 et 1 de lapse en renouvellement et resignation
data$lapse <- as.factor(data$lapse)
levels(data$lapse) <- c("renouvellement", "resignation")

# Changment des valeurs unknown en NA des variables: 
# polholder_diffdriver, vehicl_garage et policy_caruse
data[data$polholder_diffdriver == "unknown", ]$polholder_diffdriver <- NA
data[data$vehicl_garage == "unknown", ]$vehicl_garage <- NA
data[data$policy_caruse == "unknown", ]$policy_caruse <- NA

# Reordonnement de la variable prem_freqperyear en facteur ordonnée (ordinal)
data$prem_freqperyear <- factor(data$prem_freqperyear, order = TRUE, levels = c("1 per year", "2 per year", "4 per year", "12 per year"))

# Regions
data$vehicl_region <- factor(data$vehicl_region, order = TRUE, levels = c("Reg1", "Reg2", "Reg3", "Reg4", "Reg5", "Reg6", "Reg7", "Reg8", "Reg9", "Reg10", "Reg11", "Reg12", "Reg13", "Reg14"))

# Creation d un nouvelle variable prem_index=prem_final/prem_last
data$prem_index <- data$prem_final / data$prem_last - 1

# Traitement de la variable vehicl_powerkw: regroupement en 4 groupe
data$vehicl_powerkw_na <- data$vehicl_powerkw
data[data$vehicl_powerkw_na == "125-300 kW", ]$vehicl_powerkw_na <- NA
data[data$vehicl_powerkw %in% c("150 kW","175 kW","200 kW","225 kW","250 kW","275 kW","300 kW"), ]$vehicl_powerkw <- "125-300 kW"
data <- droplevels(data)
data$vehicl_powerkw <- factor(data$vehicl_powerkw, order = TRUE, levels = c("25-50 kW", "75 kW", "100 kW", "125-300 kW"))
table(data$vehicl_powerkw)

data <- data %>% select(-vehicl_powerkw_na)
data.traiter <- data
```

```{R, FonctionPrintTable, echo = FALSE, include = FALSE, warning = FALSE}

print.tables <- function(dat, caption="", label="", align=rep("c", ncol(dat)+1), digits=3, ...){
  print(xtable(dat, digits = digits,
             caption=caption,
             label=label,
             align=align),
            include.rownames = FALSE, sanitize.text.function=function(x){x},
            caption.placement = "top", comment=FALSE, ...)
}
```

\newpage

# Introduction

Les données qui seront analysées dans ce rapport proviennent du jeu de données "eudirectlapse" du paquetage "CASdatasets" de R. Dans le but de modéliser le statut de renouvellement d'une police d'assurance, représenté par la variable "lapse" dans ce cas-ci, il sera d'abord nécessaire de visualiser et de pré-traiter les données observées des 23 060 polices d'assurance. Il est à noter que la durée d'observation est de un an et que l'année visée et la compagnie demeurent inconnue. On pourra distincguer les statuts de renouvellement comme étant affiché à annulé("Cancellation") ou à renouvellement ("Renew") selon le cas approprié. 
Ce jeu de données est intéressant du fait qu'il permettera au fur de l'analyse de nous indiquer les variables types ayant un impact sur la décision de renouvellement de police des assurés d'une compagnie d'assurance X. En plus d'être un problème de nature actuarielle, le jeu de données choisi pourra nous permettre d'entammer une ouverture des réflexions possibles lorsque nous aurons à travailler dans une compagnie d'assurance. Étant trois personnes intéressés par l'assurance de dommages, ce problème nous semblait des plus appropriés et intéressant face à nos intérêts communs. Le nombre d'observations est également intéressant car il nous permettera de porter des conclusions précise avec assez de crédibilité sans toutefois être avoir à travailler avec un jeu de données inutilement trop volumineux. De plus, chaque variable explicative semble à prime à bord intéressante pour l'analyse et assez pertinente, ce que nous pourrons découvrir dans l'élaboration de ce travail pratique.

\newpage
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
# Analyse exploratoire des données

## Variable réponse
La variable lapse indique si l'assuré à renouveller ou non sa police lors du renouvellement. Il s'agit de la variable exogène. Initialement, le choix du client était indiqué par une variable binaire. Si le client désirait résigner sa police lapse prenait la valeur 1, autrement elle prenait la valeur 0. À des fins de simplification et pour que la visualisation en soit amiliorée pour la suite, nous avons converti la variable en variable catégorielle à deux niveaux. La variable prendra maintenant la valeur **`r levels(data$lapse)[2]`** si le client résigne sa police et de **`r levels(data$lapse)[1]`** s'il la renouvelle.

On constate qu'il y a `r nrow(data)` clients qui ont renouvelé alors qu'il y en a `r nrow(data[data$lapse == "renouvellement", ])` qui ont renouveller leur police d'assurance, se qui représente une proportion de `r round(nrow(data[data$lapse == "renouvellement",])/nrow(data)*100, 2)`%. La variable réponse n'est donc pas symétrique et il sera important d'en tenir compte lors de la modélisation. Pour mieux comprendre la cause de leur résignation et ainsi arriver à modéliser la variable de renouvellement de police, il sera nécessaire de faire l'analyse de variables explicatives contenus dans ce jeu de données. 

## Variables catégorielle

La variable **polholder_diffdriver** représente la différence de statut qui pourrait avoir entre le propriétaire de la police et le conducteur principale.

```{r tabl_statut, echo=FALSE, results='asis', fig.cap="\\label{tbl:statutdiff}Différence de statut"}
l1 <- c(summary(data$polholder_diffdriver)[c("all drivers > 24")])

l2 <- c(summary(data$polholder_diffdriver)[c("commercial")])

l3 <- c(summary(data$polholder_diffdriver)[c("learner 17")])

l4 <- c(summary(data$polholder_diffdriver)[c("only partner")])

l5 <- c(summary(data$polholder_diffdriver)[c("same")])

l6 <- c(summary(data$polholder_diffdriver)[c("young drivers")])

l7 <- c(summary(data$polholder_diffdriver)[c("NA's")])

ligne_name <- c("Conducteurs agée de 24+","Commerciale","Conducteur apprenti de 17 ans","Partenaire de couple", "Utilisateur seul", "Jeunes utilisateurs", "Données manquantes")
tableau_statut <- cbind(ligne_name ,rbind(l1 , l2, l3, l4, l5, l6, l7))

dat_frame_tab <- as.data.frame(tableau_statut)

colnames(dat_frame_tab) <- c("Statut", "Nombre d'observation")

print.tables(dat_frame_tab, hline.after=c(-1,0,7), digits=2, align = c("l", "l", "c"))
```

On constate que la plupart des voitures assurées est utilisée seulement par le détenteur de la police ou par l,assuré et son partenaire de couple puisque c'est deux cas représente `r round((summary(data$polholder_diffdriver)[c("only partner")] + summary(data$polholder_diffdriver)[c("same")])/nrow(data)*100, 2)`% des observations. Il y a un pourcentage non négligeable de `r round((summary(data$polholder_diffdriver)[c("young drivers")])/nrow(data)*100, 2)`% pour lequel le véhicules est partagé par de jeunes conducteurs alors qu'il y a `r summary(data$polholder_diffdriver)[c("all drivers > 24")]`% des cas ou le véhicule est plutôt partagé entre des personnes plus agées (24 ans et plus). À noté qu'il y a 12 observations pour lesquelles la variable est manquante. Cela sera traité dans la section traitement des valeurs manquantes. 


La variable **polholder_gender** représente le sexe du propriétaire de la police. Voici la répartition en pourcentage du sexe pour les propriétaires de police d'assurance.


```{r tabl_sexe, echo=FALSE, results='asis', fig.cap="\\label{tbl:sexeass}Sexe des assures"}
p1 <- c(round(summary(data$polholder_gender)[c("Male")]/nrow(data)*100, 2))

p2 <- c(round(summary(data$polholder_gender)[c("Female")]/nrow(data)*100, 2))

ligne_name <- c("Homme", "Femme")
tableau_sexe <- cbind(ligne_name ,rbind(p1 , p2))

dat_frame_tab2 <- as.data.frame(tableau_sexe)

colnames(dat_frame_tab2) <- c("Sexe", "\\%")

print.tables(dat_frame_tab2, hline.after=c(-1,0,2), digits=2)
```

On voit qu'il y a quand même significativement plus d'homme ayant une police d'assurance chez l'assureur que de femme. Possiblement pour la raison que les hommes conduise davantage une voiture.

La variable décrivant le travail du propriétaire du contrat est nommé **polholder_job**. Deux valeurs sont possibles soit "medical" soit "normal". On constate que `r round((summary(data$polholder_job)[c("medical")])/nrow(data)*100, 2)`% des assurés on un travail de type médical alors qu'il y en a `r round((summary(data$polholder_job)[c("normal")])/nrow(data)*100, 2)`% qui ont un autre type d'emploi.

La variable **policy_caruse** représente les fins d'utilisation du véhicule. 

```{r tabl_caruse, echo=FALSE, results='asis', fig.cap="\\label{tbl:caruse}Usage du vehicule"}
l1 <- c(summary(data$policy_caruse)[c("commercial")])

l2 <- c(summary(data$policy_caruse)[c("private or freelance work")])

l3 <- c(summary(data$policy_caruse)[c("NA's")])


ligne_name <- c("Commerciale","Privé ou aller travailler","Données manquantes")
tableau_caruse <- cbind(ligne_name ,rbind(l1 , l2, l3))

dat_frame_tab3 <- as.data.frame(tableau_caruse)

colnames(dat_frame_tab3) <- c("Usage", "Nombre d'observation")

print.tables(dat_frame_tab3, hline.after=c(-1,0,3), digits=2, align = c("l", "l", "c"))
```

On constate qu'il y a un nombre considérable de données manquantes et très peu de véhicule pour un usage commerciale.

De sont côté, **vehicl_garage** décrit le type de stationnement de la voiture. Voici la répartition des types de stationnement.

```{r tabl_garage, echo=FALSE, results='asis', fig.cap="\\label{tbl:garage}Type de stationnement"}
l1 <- c(summary(data$vehicl_garage)[c("carport")])

l2 <- c(summary(data$vehicl_garage)[c("parking deck")])

l3 <- c(summary(data$vehicl_garage)[c("private estate")])

l4 <- c(summary(data$vehicl_garage)[c("private garage")])

l5 <- c(summary(data$vehicl_garage)[c("street")])

l6 <- c(summary(data$vehicl_garage)[c("underground garage")])

l7 <- c(summary(data$vehicl_garage)[c("other")])

l8 <- c(summary(data$vehicl_garage)[c("NA's")])

ligne_name <- c("Sous un abri d'auto", "Terrase de stationnement", "Stationnement privé", "Garage", "Rue", "Garage sous-terrain", "Autre", "Données manquantes")
tableau_garage <- cbind(ligne_name ,rbind(l1 , l2, l3, l4, l5, l6, l7, l8))

dat_frame_tab4 <- as.data.frame(tableau_garage)

colnames(dat_frame_tab4) <- c("Moyen de stationnement", "Nombre d'observation")

print.tables(dat_frame_tab4, hline.after=c(-1,0,8), digits=2, align = c("l", "l", "c"))
```

On voit que pour les moyens de stationnement les plus populaire sont le garage privé et la rue. Il y a des données manquantes, elles seront traitées plus loin dans le rapport.

La variable polholder_BMCevol indique si la prime de renouvellement à connue une hausse, une baisse ou est demeuré stable par rapport à la prime payé lors du dernier renouvellement. Elle prend donc 3 valeurs possibles. 


```{r tabl_BM, echo=FALSE, results='asis', fig.cap="\\label{tbl:BM}Bonus Malus"}
l1 <- c(summary(data$polholder_BMCevol)[c("up")])

l2 <- c(summary(data$polholder_BMCevol)[c("stable")])

l3 <- c(summary(data$polholder_BMCevol)[c("down")])

ligne_name <- c("Hausse", "Inchangée", "Baisse")
tableau_BM <- cbind(ligne_name ,rbind(l1 , l2, l3))

dat_frame_tab5 <- as.data.frame(tableau_BM)

colnames(dat_frame_tab5) <- c("Prime de renouvellement", "Nombre d'observation")

print.tables(dat_frame_tab5, hline.after=c(-1,0,3), digits=2, align = c("l", "l", "c"))
```

On constate que la plupart des contrats ont été inchangé ou ont connu des baisses au niveau des primes. (C'est un résultat étonnant, faudrait commenter la -dessus ???) 

La variable vehicl_region représente une région de l'union européenne. Il y a 14 régions, elles sont numérotés mais nous savons pas à quel emplacement géographique cela correspond. Voici un diagramme pour visualiser comment les contrats sont dsipersées dans chacune des régions.

```{r graph_vehicl_region, echo=FALSE, fig.width=5, fig.asp=.62, fig.align="center",fig.cap="\\label{fig:vehiclregion}Distribution des régions des détenteurs de police, représenté par la variable \\textbf{polholder\\_age}"}
ggplot(data, aes(x = vehicl_region))+
  geom_bar() +
  labs(x = "Région", y = "Fréquence") + 
  theme_bw() + theme(axis.text.x = element_text(angle = 20))
```

Les assurés sont répartis dans toutes les régions on note toutefois que la région 4 est la région pour laquelle il y a le plus d'assurés.


## Variable ordinal
Variable catégorielle ordinale **prem_freqperyear** représentant la fréquence par année à laquelle la prime est payable. Les fréquence possible est mensuelle, trimestrielle, semestrielle ou annuelle.

```{r graph_prem_freqperyear, echo=FALSE, fig.width=5, fig.asp=.62, fig.align="center",fig.cap="\\label{fig:freqperyearAndvehiclGarage}todo"}
ggplot.premfreqperyear <- ggplot(data, aes(x = prem_freqperyear))+
  geom_bar() + theme_bw() + ggtitle("(1)") + theme(axis.text.x = element_text(angle = 90)) 
 

ggplot.vehicl_garage <- ggplot(data, aes(x = vehicl_garage))+
  geom_bar() + theme_bw() + ggtitle("(2)") + theme(axis.text.x = element_text(angle = 90)) 

grid.arrange(ggplot.premfreqperyear, ggplot.vehicl_garage,  ncol=2)
```
On voit qu'un peu moins de la moitié des clients paient la prime en un seul versement, environ un quart des clients paient trimestriellement, et le dernier quart est partagé par la prime payable semestriellement et mensuellement.

**vehicl_powerkw ICI**

## Variable numérique
La variable **polholder_age** est une variable numérique discrète représentant l'âge du propriétaire de la police d'assurance. La \autoref{fig:polholderAge} représente la distribution de âges des assurés.
```{r graph_polholder_age, echo=FALSE, fig.width=5, fig.asp=.62, fig.align="center",fig.cap="\\label{fig:polholderAge}Distribution de l'âge des détenteurs de polices dans la base de données, représenter par la variable \\textbf{polholder\\_age}"}
ggplot(data, aes(x = polholder_age))+
  geom_bar() +
  labs(x = "Âge du détenteur de police", y = "Fréquence") + 
  theme_bw() + facet_grid(~polholder_gender)
```
L'âge minimal parmis les assuré est de 19 ans et l'âge maximal est de 85 ans. On constate qu'il y a une forte proportion d'assuré entre 30 et 45 ans. Il pourra être pertinent d'analyser si les assurés de plus de 45 ans sont présent en moins grand nombre dû au fait que les primes sont trop élevé et font d'avantage d'appel pour comparer les primes ailleurs ce qui les mènent vers la résignation. 


Le nombre d'année sans résignation de la police d'assurance depuis la première année assurée est représenté par la variable umérique discrète **policy_age**. Avec l'aide de la \autoref{fig:policyAge} on constate une forte décroissance du nombre d'assurée pour le nombre d'années depuis l'entré en vigueur pour les 3 premières années pour ensuite ce stabilisé par la suite.
```{r graph_policy_age, echo=FALSE, fig.width=5, fig.asp=.62, fig.align="center",fig.cap="\\label{fig:policyAge}Distribution de l'âge pour laquelle une police est en vigeur, représenter par la variable \\textbf{policy\\_age}"}
ggplot(data, aes(x = policy_age))+
  geom_bar() +
  labs(x = "Âge de la police", y = "Fréquence") + 
  theme_bw() 
```


En ce qui concerne la variable discrète **policy_nbcontract** représentant le nombre de contrat, ou risque, que l'assuré possède chez l'assureur. L'histogramme illustré à la \autoref{fig:policyNbcontract} fait resortir le fait qu'il y a une forte concentration d'assuré pour lesquels le nombre de contrat qu'ils ont chez l'assureur est inférieur à 5. On peut aussi voir que certains assurés ont jusqu'à 15 contrats. 

```{r graph_policy_nbcontract, echo=FALSE, fig.width=5, fig.asp=.62, fig.align="center",fig.cap="\\label{fig:policyNbcontract}Distribution du nombre de contrats par police, représenter par la variable \\textbf{policy\\_nbcontract}"}
ggplot(data, aes(x = policy_nbcontract))+
  geom_bar() + 
  labs(x = "Nombre de contrat par police", y = "Fréquence") + 
  theme_bw() 
```


Il y a plusieurs variables numériques continues relatives à la prime. La variable **prem_final** représente le montant de la prime proposé pour le renouvellement par l'assureur alors que **prem_last** représente le montant payé lors du dernier renouvellement. La variable prem_market est la prime qui serait chargée selon le marché. La variable prem_pure est la prime qui représente les coûts espérés pour un assuré. Le \autoref{tbl:summaryPrimes} montre les distributions de chaqune des primes. Par contre, une prime seul peut difficilement expliquer pourquoi un assuré voudrais résigné car si l'assuré mérite réellement sa prime, il n'aurait pas intérêt à aller chez un concurant. Par contre, si lors de sont renouvellement, il voit sont montant d'assurance augmenter d'un grand poucentage, il serat tenté d'aller voir ayeur. C'est pourquoi la variable **prem_index** à été crée et ajouté à notre jeu de données. celle-ci représente le pourcentage d'augmentation de la prime, sois la prime final divisé par la prime du dernier terme.
```{r stats_prem, echo=FALSE, results='asis', fig.cap="\\label{tbl:summaryPrimes}Distribution des variables consernant les primes de l'assuré"}
stats_final <- c(summary(data$prem_final)[c(1, 3, 4, 6)], sd(data$prem_final))

stats_last <- c(summary(data$prem_last)[c(1, 3, 4, 6)], sd(data$prem_last))

stats_market <- c(summary(data$prem_market)[c(1, 3, 4, 6)], sd(data$prem_market))

stats_pure <- c(summary(data$prem_pure)[c(1, 3, 4, 6)], sd(data$prem_pure))

stats_index <- c(summary(data$prem_index)[c(1, 3, 4, 6)], sd(data$prem_index))

prime_type <- c("Final","Last","Market","Pure", "Index (\\%)")
tableau_stats <- cbind(prime_type ,rbind(round(stats_final, 2), round(stats_last, 2), round(stats_market, 2), round(stats_pure, 2), round(stats_index, 2)))

dat_frame_tab <- as.data.frame(tableau_stats)

colnames(dat_frame_tab) <- c("Prime (\\$)", "Minimum", "Médiane", "Moyenne", "Maximum", "Écart-type")

print.tables(dat_frame_tab, hline.after=c(-1,0,4,5), digits=2, align = c("l", "l", rep("c",5)))
```


Les deux prochaines variables sont en lien avec l'aĝe du véhicule, il s'agit de variables numériques discrètes. La variable vehicl_agepurchase représente l'âge du véhicule lorsque l'assuré a acheté le véhicule. La variable vehicl_age représente l'aĝe du véhicule actuellement. 

```{r graph_age, echo=FALSE, fig.width=5, fig.asp=.62, fig.align="center",fig.cap="\\label{fig:}todo"}
agepurchase_vehicule <- ggplot(data, aes(x = vehicl_agepurchase))+
  geom_bar() + theme_bw() + ggtitle("(1)") 

age_vehicule <- ggplot(data, aes(x = vehicl_age))+
  geom_bar()+ theme_bw() + ggtitle("(2)") 


grid.arrange(agepurchase_vehicule, age_vehicule,  ncol=2)

```

Beaucoup de véhicule ont été achetés lorsqu'il était neuf (vehicl_purchase = 0). En examinant les véhicules conduits par es assurés on remarque qu'il y a peu de véhicule neuf et le nombre de véhicule est croissant en fonction de l'utilisation jusqu'à 13 ans puis décroit par la suite. On retrouve un grand nombre de véhicule assuré avec 18 ans d'usage, il est fort probable que cela correspondre aux véhicules de plus de 18 ans. 



\newpage

# Autres sections
# Traitement des valeurs manquantes
```{R, ProportionDeValeursManquante, echo = FALSE, results='asis'}
nb_manquant <- round(apply(data, 2, FUN = function(x) sum(is.na(x)))/nrow(data) * 100,2)
```
La base de données contenait seulement trois variables avec des valeurs manquante. La variable indiquant la difference d'âge entre le détenteur de police et le conducteur est manquante à `r nb_manquant[["polholder_diffdriver"]]`%, celle indiquant l'utilité du vehicule est manquante à `r nb_manquant[["policy_caruse"]]`% et la variable indiquant le type de garage où est entreposé le vehicule est manquante à `r nb_manquant[["vehicl_garage"]]`%. La \autoref{fig:missingPatern} montre le patron des valeurs manquantes. On remarque que les trois variables manquantes semblent liées entres-elles. En effet, la totalité des cas manquants pour la variable *polholder_diffdriver* sont aussi manquants pour les deux autres variables nommées précédemmment. En ce qui concerne les variables *policy_caruse* et *vehicl_garage*, elles sont majoritairement manquantes pour une variable seulement mais quelques exceptions subsistent.

```{R, MissingPattern, echo=FALSE, results="hide", fig.with=3, fig.height=3, fig.align="center", fig.cap="\\label{fig:missingPatern}ddd"}
#pattern.matrix <- md.pattern(data, rotate.names = TRUE)
missing.pathern <- aggr(data, combined = TRUE, ylabs="",labels=c("","","","diffdriver","","","","caruse","","","","","","","","","garage","",""), sortVars=TRUE)
```

Ensuite, dans le but de déterminer si les données manquantes sont MCAR, nous avons effectué le test d'hypothèse suivant
\begin{align*}
  H_0:&\: \text{Le données sont MCAR} \\
  H_1:&\: \text{Le données ne sont pas MCAR}
\end{align*}
La statistique a été calculé avec le test *MCAR de Little* et une p-value inférieure à 1% a été obtenue. Avec un niveau de signification de 1%, il est possible de rejeter l'hypothèse, soit que les données sont de type MCAR. Il est à noter qu'il n'est pas possible de vérifier avec certitude si les données sont MAR ou NMAR. Cela est dû au fait que puisque les données proviennent d'un compagnie inconnue, nous n'avons pas d'information sur la méthode de récolte de données et il nous est impossible de trouver des patrons qui pourraient provoquer des données de type NMAR. En conséquence, nous considérerons que nos données sont MAR. De ce sens, en effectuant des tests khi-carré pour la variable *polholder_diffdriver*, il a été remarqué que l'information sur la différence entre le détenteur de police et le conducteur nous indique que les variables sont toujours manquantes dans le cas ou le travail du détenteur de la police est dans le domaine de la médecine et que la durée de la police d'assurance est d'au moins 4 ans. Ceci renforce l'idée que le patrons de non réponse pour cette variable dépend des variables observés dans le jeux de données.

Pour l'imputation des données, la méthode d'imputation multiples à été choisie. Pour des restrictions de temps de calcul, cinq itérations de régression stochastique ont été fait. Pour la variable *policy_caruse*, une régression logistique a été effectué puisque la variable catégorielle comporte deux niveaux. Pour les variables *vehicl_garage* et *polholder_diffdriver*, qui sont des variables catégorielles non-ordonées, une régression polynomiale a été utilisée.

```{R, ImputationDesDonnees, echo = FALSE, eval=FALSE, warning = FALSE}
methode <- c("sample","sample","sample","polyreg","sample","sample","sample","logreg","sample","sample","sample","sample","sample","sample","sample","sample","polyreg","sample","sample")
donnees.imp <- mice(data, m=5, method=methode, print=TRUE, seed=1095)
summary(donnees.imp)

data.compl <- mice::complete(donnees.imp)
save(data.compl,file="dataCompletTraiter.Rda")
# Il ne reste bien plus de donnees.
apply(data.compl, 2, FUN = function(x) sum(is.na(x)))
```
```{R, LoadImputationDesDonnees, echo = FALSE, result=FALSE, warning = FALSE}
load("dataCompletTraiter.Rda")
```


```{R, TraitementDesValeursManquantes, echo = FALSE, eval = FALSE, warning = FALSE}
data <- data.traiter %>% select(-vehicl_powerkw_na)
# Get number of NA value for each variables
apply(data, 2, FUN = function(x) sum(is.na(x)))
pattern.matrix <- md.pattern(data, rotate.names = TRUE)

test.MCAR <- function(var.data, na_var.data){
  if(is.numeric(data[[var.data]])){
    round(t.test(data[[var.data]][is.na(data[[na_var.data]])],
                    data[[var.data]][!is.na(data[[na_var.data]])],var.equal=FALSE)[["p.value"]], 5) 
  }else{
    round(chisq.test(data[[var.data]], is.na(data[[na_var.data]]), correct=FALSE)[["p.value"]], 5)
  }
}
# Tester pour la variable vehicl_garage
sapply(names(data  %>% select(-vehicl_garage)), FUN=test.MCAR, na_var.data = "vehicl_garage")
 

# teste pour la variable polholder_diffdriver
sapply(names(data  %>% select(-polholder_diffdriver, -vehicl_garage, -policy_caruse)), FUN=test.MCAR, na_var.data = "polholder_diffdriver")
# On rejete H0(MCAR)a 5% pour polholder_job et policy_age: On remarque que  
# tout les cas manquant pour la variable polholder_diffdriver sont polholder_job=medical
# policy_age sont plus vielle > 3-4
data[is.na(data$polholder_diffdriver), c("lapse", "polholder_job", "policy_age", "polholder_diffdriver", "vehicl_garage")]

sapply(names(data  %>% select(-vehicl_garage)), FUN=test.MCAR, na_var.data = "vehicl_garage")

table(data$polholder_diffdriver[data$polholder_job == "medical"])
table(data$polholder_job)

stat <- LittleMCAR(data)
names(stat)
stat$chi.square
stat$df
nrow(data)
round(pchisq(stat$chi.square, stat$df, lower.tail = FALSE), 18)
```


\newpage

# Analyse en composantes principales
Étant donné que notre jeu de données contient `R nrow(Donnees_tempo)` observations, il peut être utile de visualiser les données à l'aide de l'analyse en composantes principales, appelé ACP. En effet, ce type d'analyse permet de mieux visualiser un jeu de données lorsque celui-ci est de grande dimension. Il sera ainsi possible de voir quelles variables explicatives sont plus intéressantes par leur impact sur la variance des composantes principales. Il est à noter qu'en général, on garde assez de composantes pour représenter entre 80 et 90 % de la variance totale. 

Pour que cette méthode de visualisation puisse être utilisée, il sera nécessaire de prendre seulement les variables explicatives numériques de ce jeu de donnée. Les variables catégorielles ne seront pas analysées dans cette section car même en les transformant en variables numériques, elles ne seront pas représentative de leur signification.

```{R , echo = FALSE, include = TRUE}
Donnees_tempo <- na.omit(data)
Data_num <- Donnees_tempo[, c("polholder_age", "policy_age", "policy_nbcontract", "prem_final", "prem_last", "prem_market", 
                              "prem_pure", "vehicl_age", "vehicl_agepurchase")]
```

On doit ensuite choisir le nombre de composantes principales. Cette étape peut être complétée en spécifiant le pourcentage de variance expliquée pour obtenir la cible précisée précedemment ou utiliser la méthode du coude sur le diagramme d'éboulis. 

```{R , echo = FALSE, include = FALSE}
ACP <- PCA(Data_num, scale = TRUE, ncp = 6)  #scale=TRUE permet de normaliser les données. Pourtant les variables n'ont pas a voir des échelles converti ? je crois. 
#si on fait scale=FALSE le graphique est laid. Vous en pensez quoi
```

```{R , echo = FALSE, include = TRUE}
fviz_screeplot(ACP)
```

Selon le diagramme d'éboulis, il sera nécessaire de conserver 6 composantes principales et on observe, à l'aide des valeurs propres de la matrice de corélation, que 6 composantes principales permettent d'expliquer 97% de la variance totale.

À l'aide du graphique ACP des variables, on peut voir la gravité des contributions pour chacune des variables sur chacune des composantes principales retenu. Ainsi, on peut observer que pour la première composante principale, un score élevé indique un contrat ayant une prime élevée, que ce soit la prime du marché, la prime pure, la prime finale ou la prime chargée lors du dernier renouvellement. Par contre, un assuré âgé qui renouvelle depuis plusieurs année aura un score moindre qu'un assuré en bas âge ayant une police d'assurance récente. Un score élevé représente donc un assuré en bas âge ayant une police récente et une prime élevé tandis qu'un score faible représente une personne plus âgée avec une faible prime d'assurance. 

La deuxième composante principale représente, quant à elle, l'âge du véhicule assuré. Un score élevé est associé à des véhicules de moindres valeurs mais risquant d'avantage un bris de veillesse. Plus les polices d'assurance sont récentes et plus le score en sera augmenté. Ainsi, les polices d'assurances récente ayant des véhicules de l'année représenteront les scores les plus faibles pour cette composante.

Pour ce qui est de la troisième composante principale, elle représente l'âge du véhicule, l'âge de l'assuré et l'âge de la police. Le score sera le plus élevé quand le véhicule est plus âgé tout comme le détenteur de la police d'assurance et que la police est renouveller depuis un grand nombre d'année. En sens inverse, le score sera de plus en plus faible si le détenteur de la police est jeune, qu'il possède une voiture de l'année et une police d'assurance très récente. 

Les trois dernières composantes sont moins intéressantes pour l'analyse et ne seront utilisés que pour déterminer le nombre de variables numériques à conserver pour les analyses qui suiveront pour la complétion de ce travail pratique. Une information qui pourrait tout de même être pertinente est qu'un score élevé sous la quatrième composante indique un nombre élevé de contrat tout en ayant une police d'assurance qui est renouvellé depuis plusieurs années. Des caractéristiques recherchées qui permettent de facilement identifier une clientèle fidèle et fiable. 

```{R , echo = FALSE, include = FALSE}
ACP$eig
ACP$var$contrib
```

En illustrant les contributions des variables pour chacune des composantes principales, il est plus facile de visualiser les conclusions mentionnées précédemment.

```{R , message=FALSE, include = TRUE, echo = FALSE}
contrib <- data.frame(ACP$var$coord[,1:6])
contrib$carac <- rownames(contrib)
contrib.long <- reshape2::melt(contrib)

ggplot(contrib.long, aes(x=carac, fill=variable, y=value))+
  geom_bar(stat="identity",position=PositionDodge)+
  facet_grid(~variable)+
  theme(legend.position="top",axis.text.x = element_text(angle = 90))+
  coord_flip()
```

<<<<<<< HEAD
## Graphique présentant les résultats de l'ACP

À voir si on les gardes ou pas (?)

```{R , echo = FALSE, include = TRUE}
data <- cbind(Donnees_tempo, ACP$ind$coord)

g_ind <- ggplot(data = data,
             aes(x= Dim.2, y=Dim.3, col = policy_age,  shape = lapse, labels = polholder_age,
                 alpha = 0.2)) +
  geom_point() +
  xlab("Dimension 2") +
  ylab("Dimension 3") +
  theme_bw()
#ggplotly(g_ind) #Pour comparer les dimensions 2 et 3

g_ind <- ggplot(data = data,
             aes(x= Dim.1, y=Dim.2, col = vehicl_agepurchase,  shape = lapse, labels = prem_pure,
                 alpha = 0.2)) +
  geom_point() +
  xlab("Dimension 1") +
  ylab("Dimension 2") +
  theme_bw()
#ggplotly(g_ind) #Pour comparer les dimensions 1 et 2

g_ind <- ggplot(data = data,
             aes(x= Dim.1, y=Dim.3, col = policy_age,  shape = lapse, labels = prem_pure,
                 alpha = 0.2)) +
  geom_point() +
  xlab("Dimension 1") +
  ylab("Dimension 3") +
  theme_bw()
#ggplotly(g_ind) #Pour comparer les dimensions 1 et 3


##À VÉRIFIER S'IL NE FAUT PAS INCLURE LES VARIABLES CATEGORIELLE ORDINALE TRANSFORMÉES EN VARIABLE NUMÉRQUES
```


\newpage

# Partitionnement en k moyennes

Le partitionnement en k moyennes est utiliser pour classifier les observations en k groupes distincts. La valeur de k est une valeur qu'on transmet pour indiquer le nombre de partitions désirées. Chaque observation sera ensuite assigné à un seul groupe. L'algorithme utilisée pour ce type de partitionnement a pour objectif de minimiser la variance intra-groupe.

```{R , echo = FALSE, include = TRUE}
Data_num <- Donnees_tempo[, c("polholder_age", "policy_age", "policy_nbcontract", "prem_final", "prem_last", "prem_market", 
                              "prem_pure", "vehicl_age", "vehicl_agepurchase")]

K <- 5
kmoyennes <- kmeans(Data_num, K, nstart=5)
Donnees_acp <- PCA(Data_num, scale = FALSE, ncp = 6, graph = FALSE)

composante1 <- Donnees_acp$ind$coord[,1]
composante2 <- Donnees_acp$ind$coord[,2]


groupe <- as.factor(kmoyennes$cluster)


ggplot() + geom_point(aes(composante1, composante2, color = groupe)) + theme_minimal()
```

\newpage

# Conclusion


\newpage

# Annexe

Notre jeu de données représente le statut de renouvellement pour 23 060 polices d'assurance basées sur un an d'observation. Les données receuillies proviennent d'une compagnie d'assurance inconnue dont l'année d'observation est également inconnue.
