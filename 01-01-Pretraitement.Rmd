---
header-includes: \usepackage[french]{babel} \usepackage{hyperref} \hypersetup{ colorlinks=true,
  linkcolor=blue, filecolor=magenta, urlcolor=cyan, }
output:
  pdf_document: default
  html_document:
    df_print: paged
---

\newpage
\begin{flushright}
    \textbf{Équipe 8}
\end{flushright}

\begin{center}
    \vspace{2\baselineskip}
    Charles Comeau \\
    (111 185 421) \\
    \vspace{1\baselineskip}
    Nicholas Langevin \\
    (111 184 631) \\
    \vspace{1\baselineskip}
    Andréanne Larouche \\
    (111 190 518) \\
    \vspace{7\baselineskip}
    Apprentissage statistique en actuariat\\
    ACT-3114 \\
    \vspace{7\baselineskip}
    {\large
    \textbf{Analyse des données de renouvellement d'assurance}} \\
    \vspace{8\baselineskip}
    présenté à \\
    Marie-Pier Côté \\
    \vspace{9\baselineskip}
    École d’actuariat \\
    Université Laval \\
    27 février 2020
\end{center}

\newpage

\tableofcontents
```{R, LoadingPackages, echo = FALSE, include = FALSE, warning = FALSE}
library(CASdatasets)
library(tidyverse)
library(mice)
library(xtable)
library(reshape2)
library(VIM)
```

```{R, TraitementDesDonnees, echo = FALSE, include = FALSE, warning = FALSE}
data(eudirectlapse)
data.init <- eudirectlapse

## Changement dans les donnees
data <- data.init

# Changement des 0 et 1 de lapse en renouvellement et resignation
data$lapse <- as.factor(data$lapse)
levels(data$lapse) <- c("renouvellement", "resignation")

# Changment des valeurs unknown en NA des variables: 
# polholder_diffdriver, vehicl_garage et policy_caruse
data[data$polholder_diffdriver == "unknown", ]$polholder_diffdriver <- NA
data[data$vehicl_garage == "unknown", ]$vehicl_garage <- NA
data[data$policy_caruse == "unknown", ]$policy_caruse <- NA

# Reordonnement de la variable prem_freqperyear en facteur ordonnée (ordinal)
data$prem_freqperyear <- factor(data$prem_freqperyear, order = TRUE, levels = c("1 per year", "2 per year", "4 per year", "12 per year"))

# Traitement de la variable vehicl_powerkw: regroupement en 4 groupe
data$vehicl_powerkw_na <- data$vehicl_powerkw
data[data$vehicl_powerkw_na == "125-300 kW", ]$vehicl_powerkw_na <- NA
data[data$vehicl_powerkw %in% c("150 kW","175 kW","200 kW","225 kW","250 kW","275 kW","300 kW"), ]$vehicl_powerkw <- "125-300 kW"
data <- droplevels(data)
data$vehicl_powerkw <- factor(data$vehicl_powerkw, order = TRUE, levels = c("25-50 kW", "75 kW", "100 kW", "125-300 kW"))
table(data$vehicl_powerkw)

data <- data %>% select(-vehicl_powerkw_na)
data.traiter <- data
```

```{R, FonctionPrintTable, echo = FALSE, include = FALSE, warning = FALSE}

print.tables <- function(dat, caption="", label="", align=rep("c", ncol(dat)+1), ...){
  print(xtable(dat, digits = 3,
             caption=caption,
             label=label,
             align=align, ...),
            include.rownames = FALSE, sanitize.text.function=function(x){x},
            caption.placement = "top", comment=FALSE)
}
```

```{R , echo = FALSE, include = FALSE, warning = FALSE}

## Diagramme à bande des frequence de renouvellement et decheance en fonction des variables categorielles 
ggplot(data, aes(x=lapse, fill=polholder_BMCevol))+
  geom_bar(position="dodge")
ggplot(data, aes(x=lapse, fill=polholder_diffdriver))+
  geom_bar(position="dodge")
ggplot(data, aes(x=lapse, fill=polholder_gender))+
  geom_bar(position="dodge")
ggplot(data, aes(x=lapse, fill=policy_caruse))+
  geom_bar(position="dodge")
ggplot(data, aes(x=lapse, fill=prem_freqperyear))+
  geom_bar(position="dodge")
ggplot(data, aes(x=lapse, fill=vehicl_garage))+
  geom_bar(position="dodge")
ggplot(data, aes(x=lapse, fill=vehicl_powerkw))+
  geom_bar(position="dodge")
ggplot(data, aes(x=lapse, fill=vehicl_region))+
  geom_bar(position="dodge")

```

\newpage

# Introduction

Les données qui seront analysées dans ce rapport proviennent du jeu de données "eudirectlapse" du paquetage "CASdatasets" de R. Dans le but de modéliser le statut de renouvellement d'une police d'assurance, il sera d'abord nécessaire de visualiser et de pré-traiter les données observées des 23 060 polices d'assurance. Il est à noter que la durée d'observation est de un an et que l'année visée et la compagnie demeurent inconnue. Ainsi, "lapse", variable de type catégorielle qui indique si l'assuré résignera lors de son renouvellement d'assurance ou non, est la variable réponse qui sera intéressante.

\newpage

# Analyse exploratoire des données

## lapse

La variable lapse indique si l'assuré à renouveller ou non sa police lors du renouvellement. Il s'agit de la variable exogène. Initialement, le choix du client était indiqué par une variable binaire, soit une variable catégorique nominale. Si le client désirait résigner sa police lapse prenait la valeur 1, autrement elle prenait la valeur 0. À des fins de simplification et de compréhension générale, nous avons converti la variable en variable pour que la visualisation en soit augmentée pour la suite. La variable prendra maintenant la valeur "cancelation" si le client à décider de résigner sa police et de "renew" s'il a décider de la renouveller.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.with=3, fig.height=3, fig.align="center")
```

On constate qu'il y a `R nrow(data)` clients qui ont renouvelé alors qu'il y en a `R nrow(data[data$lapse == "renew"])` qui ont renouveller leur police d'assurance, soit  `R nrow(data[data$lapse == "renew"]/nrow(data)*100`% des `R nrow(data)` clients. Pour mieux comprendre la cause de leur résignation et ainsi arriver à modéliser la variable de renouvellement de police, il sera nécessaire de faire l'analyse de variables explicatives contenus dans ce jeu de données. 

## polholder_age

Cette variable est une variable numérique discrète représentant l'âge du propriétaire de la police d'assurance. Voici un tableau de fréquence des âges des assurés.

```{r graph_polholder_age, echo = FALSE, eval = TRUE, include = TRUE, warning = FALSE}
ggplot(data, aes(x = polholder_age))+
  geom_bar() +
  theme_bw()
```

L'âge minimal parmis les assuré est de 19 ans et l'âge maximal est de 85 ans. On constate qu'il y a une forte proportion d'assuré entre 30 et 45 ans. Il pourra être pertinent d'analyser si les assurés de plus de 45 ans sont présent en moins grand nombre dû au fait que les primes sont trop élevé et font d'avantage d'appel pour comparer les primes ailleurs ce qui les mènent vers la résignation. 


## polholder_BMCevol




## polholder_diffdriver

Il s'agit d'une variable catégorielle nominale représentant la différence de statut qui pourrait avoir entre le propriétaire de la police et le conducteur principale.
FAIRE UN PETIT RÉSUMÉ DU NOMBRE D'OBS DANS CHAQUE CATEGORIE. (TABLEAU) 

## polholder_gender

Variable catégorielle nominale représentant le sexe du propriétaire de la police. Voici la répartition du sexe du propriétaire de la police d'assurance.
ÉCRIRE LE NOMBRE PAR CATEGORIE (%)

## polholder_job

Variable catégorielle nominale décrivant le travail du propriétaire du contrat. Deux valeurs sont possibles soit "medical" soit "normal". 
ÉCRIRE EN POURCENTAGE (%)


## policy_age

Variable numérique discrète représentant le nombre d'année sans résignation de la police d'assurance depuis la première année assurée. 

```{r graph_policy_age, echo = FALSE, eval = TRUE, include = TRUE, warning = FALSE}
ggplot(data, aes(x = policy_age))+
  geom_bar()
```

On constate une forte décroissance du nombre d'assurée pour le nombre d'années depuis l'entré en vigueur pour les  3 premières années pour ensuite ce stabilisé par la suite.

## policy_caruse

Variable catégorielle nominale représentant les fins d'utilisation du véhicule. ÉCRIRE EN %    

On constate qu'il y a un nombre considérable de données manquantes et très peu de véhicule pour un usage commerciale.


## policy_nbcontract

Variable numérique discrète représentant le nombre de contrat que possède l'assuré chez l'assureur. 

```{r graph_policy_nbcontract, echo = FALSE, eval = TRUE, include = TRUE, warning = FALSE}
ggplot(data, aes(x = policy_nbcontract))+
  geom_bar()
```

L'histogramme illustre le fait qu'il y a une forte concentration d'assuré pour lesquels le nombre de contrat qu'ils ont chez l'assureur est inférieur à 5. On peut aussi voir que certains assurés ont jusqu'à 15 contrats. 


## Les variables de primes

Il y a plusieurs variables numériques continues relatives à la prime. La variable prem_final re présente le montant de la prime proposé pour le renouvellement par l'assureur alors que prem_last représente le montant payé lors du dernier renouvellement. La variable prem_market est la prime qui serait chargée selon le marché. La variable prem_pure est la prime pure.    

```{r stats_prem, echo = FALSE, eval = TRUE, include = TRUE, warning = FALSE, results='asis'}
stats_final <- c(summary(data$prem_final)[c(1, 3, 4, 6)], sd(data$prem_final))

stats_last <- c(summary(data$prem_last)[c(1, 3, 4, 6)], sd(data$prem_last))

stats_market <- c(summary(data$prem_market)[c(1, 3, 4, 6)], sd(data$prem_market))

stats_pure <- c(summary(data$prem_pure)[c(1, 3, 4, 6)], sd(data$prem_pure))

tableau_stats <- rbind(stats_final, stats_last, stats_market, stats_pure)

dat_frame_tab <- as.data.frame(tableau_stats)

colnames(dat_frame_tab) <- c("Minimum", "Médiane", "Moyenne", "Maximum", "Écart-type")

print.tables(dat_frame_tab)
```


## prem_freqperyear

Variable catégorielle ordinale représentant la fréquence par année à laquelle la prime est payable. Les fréquence possible est mensuelle, trimestrielle, semestrielle ou annuelle.

```{r graph_prem_freqperyear, echo = FALSE, eval = TRUE, include = TRUE, warning = FALSE}
ggplot(data, aes(x = prem_freqperyear))+
  geom_bar()
```
On voit qu'un peu moins de la moitié des clients paient la prime en un seul versement, environ un quart des clients paient trimestriellement, et le dernier quart est partagé par la prime payable semestriellement et mensuellement.


## Variables relatives à l'âge du véhicule

Les deux prochaines variables sont en lien avec l'aĝe du véhicule, il s'agit de variables numériques discrètes. La variable vehicl_agepurchase représente l'âge du véhicule lorsque l'assuré a acheté le véhicule. La variable vehicl_age représente l'aĝe du véhicule actuellement. 

```{r graph_age, echo = FALSE, eval = TRUE, include = TRUE, warning = FALSE}
library(gridExtra)
library(grid)
library(lattice)
age_vehicule <- ggplot(data, aes(x = vehicl_age))+
  geom_bar()

agepurchase_vehicule <- ggplot(data, aes(x = vehicl_agepurchase))+
  geom_bar()

grid.arrange(agepurchase_vehicule, age_vehicule,  ncol=2)

```

Beaucoup de véhicule ont été achetés lorsqu'il était neuf (vehicl_purchase = 0). En examinant les véhicules conduits par es assurés on remarque qu'il y a peu de véhicule neuf et le nombre de véhicule est croissant en fonction de l'utilisation jusqu'à 13 ans puis décroit par la suite. On retrouve un grand nombre de véhicule assuré avec 18 ans d'usage, il est fort probable que cela correspondre aux véhicules de plus de 18 ans. 


## vehicl_garage

Variable catégorielle nominale décrivant le type de stationnement de la voiture. Voici la répartition des types de stationnement.

```{r graph_vehicl_garage, echo = FALSE, eval = TRUE, include = TRUE, warning = FALSE}
ggplot(data, aes(x = vehicl_garage))+
  geom_bar() + theme(axis.text.x = element_text(angle = 90))
```

On voit que les moyens de stationnement les plus populaire sont le garage privé et la rue.


## 


\newpage

# Autres sections
# Traitement des valeurs manquantes
```{R, ProportionDeValeursManquante, echo = FALSE, results='asis'}
nb_manquant <- round(apply(data, 2, FUN = function(x) sum(is.na(x)))/nrow(data) * 100,2)
```
La base de données contenait seulement trois variables avec des valeurs manquante. La variable indiquant la difference d'âge entre le détenteur de police et le conducteur est manquante à `r nb_manquant[["polholder_diffdriver"]]`%, l'utilité du vehicule est manquante à `r nb_manquant[["policy_caruse"]]`% et le type de garage où est entreposé le vehicule est manquante à `r nb_manquant[["vehicl_garage"]]`%. La \autoref{fig:missingPatern} montre le patron des valeur manquante. On remarque que les trois variables manquante semble lier. En effet, 100% des cas manquant pour la variale *polholder_diffdriver* sont aussi manquantes pour les deux autres variables. En ce qui concerne les variables *policy_caruse* et *vehicl_garage*, il sont plus souvent manquante seulement pour une variable à la fois, mais il y a quelques cas où les deux sont manquantes en même temps.

```{R, MissingPattern, echo=FALSE, results="hide", fig.with=3, fig.height=3, fig.align="center", fig.cap="\\label{fig:missingPatern}ddd"}
#pattern.matrix <- md.pattern(data, rotate.names = TRUE)
missing.pathern <- aggr(data, combined = TRUE, ylabs="",labels=c("","","","diffdriver","","","","caruse","","","","","","","","","garage","",""), sortVars=TRUE)
```

Ensuite, dans le but de déterminé si les données manquante était MCAR, nous avons effectuer le test d'hypothese suivant
\begin{align*}
  H_0:&\: \text{Le données sont MCAR} \\
  H_1:&\: \text{Le données ne sont pas MCAR}
\end{align*}
La statistique à été calculer avec le test *MCAR de Little* et une p-value inférieure à 1% à été obtenu. Avec un niveau de signifiance de 1%, il est possible de regeté l'hypothese que les données sont MCAR. Ensuite, il n'est pas possible de vérifier avec certitude si les données sont MAR ou NMAR. Puisque les données proviennent d'un compagie anonyme, nous n'avons pas d'information sur la récolte de données et il nous est imposible de trouver des patrons qui pourrait provoquer des données NMAR. En conséquence, nous allons considéré que nos données sont MAR. De plus, en effectuant des tests khi-carré pour la variable polholder_diffdriver, il a été remarquer que, dans 100% des cas, l'information sur la difference entre le détenteur de police et le conducteur étaient manquante dans le cas que le travail était dans le domaine de la médecine et que pour les polices vieille d'au moins 4 ans. Ceci renforce l'idée que le patrons de non réponse pour cette variable dépend des variables observés dans le jeux de données.

Pour l'imputation des données, la méthode d'imputation multiples à été choisie. Pour des restrictions de temps de calcul, 5 itérations de régresion stochastique on été fait. Pour la variable *policy_caruse*, un régression logistique à été effectuer puisque la variable consiste en deux niveau. Pour les variables *vehicl_garage* et *polholder_diffdriver* qui sont des variable catégoriel non-ordonée, un régression polynomial à été utilisé.

```{R, ImputationDesDonnees, echo = FALSE, eval=FALSE, warning = FALSE}
methode <- c("sample","sample","sample","polyreg","sample","sample","sample","logreg","sample","sample","sample","sample","sample","sample","sample","sample","polyreg","sample","sample")
donnees.imp <- mice(data, m=5, method=methode, print=TRUE, seed=1095)
summary(donnees.imp)

data.compl <- mice::complete(donnees.imp)
save(data.compl,file="dataCompletTraiter.Rda")
# Il ne reste bien plus de donnees.
apply(data.compl, 2, FUN = function(x) sum(is.na(x)))
```
```{R, LoadImputationDesDonnees, echo = FALSE, result=FALSE, warning = FALSE}
load("dataCompletTraiter.Rda")
```


```{R, TraitementDesValeursManquantes, echo = FALSE, eval = FALSE, warning = FALSE}
data <- data.traiter %>% select(-vehicl_powerkw_na)
# Get number of NA value for each variables
apply(data, 2, FUN = function(x) sum(is.na(x)))
pattern.matrix <- md.pattern(data, rotate.names = TRUE)

test.MCAR <- function(var.data, na_var.data){
  if(is.numeric(data[[var.data]])){
    round(t.test(data[[var.data]][is.na(data[[na_var.data]])],
                    data[[var.data]][!is.na(data[[na_var.data]])],var.equal=FALSE)[["p.value"]], 5) 
  }else{
    round(chisq.test(data[[var.data]], is.na(data[[na_var.data]]), correct=FALSE)[["p.value"]], 5)
  }
}
# Tester pour la variable vehicl_garage
sapply(names(data  %>% select(-vehicl_garage)), FUN=test.MCAR, na_var.data = "vehicl_garage")
 

# teste pour la variable polholder_diffdriver
sapply(names(data  %>% select(-polholder_diffdriver, -vehicl_garage, -policy_caruse)), FUN=test.MCAR, na_var.data = "polholder_diffdriver")
# On rejete H0(MCAR)a 5% pour polholder_job et policy_age: On remarque que  
# tout les cas manquant pour la variable polholder_diffdriver sont polholder_job=medical
# policy_age sont plus vielle > 3-4
data[is.na(data$polholder_diffdriver), c("lapse", "polholder_job", "policy_age", "polholder_diffdriver", "vehicl_garage")]

sapply(names(data  %>% select(-vehicl_garage)), FUN=test.MCAR, na_var.data = "vehicl_garage")

table(data$polholder_diffdriver[data$polholder_job == "medical"])
table(data$polholder_job)

stat <- LittleMCAR(data)
names(stat)
stat$chi.square
stat$df
nrow(data)
round(pchisq(stat$chi.square, stat$df, lower.tail = FALSE), 18)
```


\newpage

# Analyse en composantes principales
```{R , echo = FALSE, include = FALSE}
require(tidyverse)
require(FactoMineR)
require(factoextra)
require(plotly)
require(ggplot2)
library(cluster)
```

Étant donné que notre jeu de données contient `R nrow(Donnees_tempo)` observations, il peut être utile de visualiser les données à l'aide de l'analyse en composantes principales, appelé ACP. En effet, ce type d'analyse permet de mieux visualiser un jeu de données lorsque celui-ci est de grande dimension. Il sera ainsi possible de voir quelles variables explicatives sont plus intéressantes par leur impact sur la variance des composantes principales. Il est à noter qu'en général, on garde assez de composantes pour représenter entre 80 et 90 % de la variance totale. 

Pour que cette méthode de visualisation puisse être utilisée, il sera nécessaire de prendre seulement les variables explicatives numériques de ce jeu de donnée. Les variables catégorielles ne seront pas analysées dans cette section car même en les transformant en variables numériques, elles ne seront pas représentative de leur signification.

```{R , echo = FALSE, include = TRUE}
Donnees_tempo <- na.omit(data)
Data_num <- Donnees_tempo[, c("polholder_age", "policy_age", "policy_nbcontract", "prem_final", "prem_last", "prem_market", 
                              "prem_pure", "vehicl_age", "vehicl_agepurchase")]
```

On doit ensuite choisir le nombre de composantes principales. Cette étape peut être complétée en spécifiant le pourcentage de variance expliquée pour obtenir la cible précisée précedemment ou utiliser la méthode du coude sur le diagramme d'éboulis. 

```{R , echo = FALSE, include = FALSE}
ACP <- PCA(Data_num, scale = TRUE, ncp = 6)  #scale=TRUE permet de normaliser les données. Pourtant les variables n'ont pas a voir des échelles converti ? je crois. 
#si on fait scale=FALSE le graphique est laid. Vous en pensez quoi
```

```{R , echo = FALSE, include = TRUE}
fviz_screeplot(ACP)
```

Selon le diagramme d'éboulis, il sera nécessaire de conserver 6 composantes principales et on observe, à l'aide des valeurs propres de la matrice de corélation, que 6 composantes principales permettent d'expliquer 97% de la variance totale.

À l'aide du graphique ACP des variables, on peut voir la gravité des contributions pour chacune des variables sur chacune des composantes principales retenu. Ainsi, on peut observer que pour la première composante principale, un score élevé indique un contrat ayant une prime élevée, que ce soit la prime du marché, la prime pure, la prime finale ou la prime chargée lors du dernier renouvellement. Par contre, un assuré âgé qui renouvelle depuis plusieurs année aura un score moindre qu'un assuré en bas âge ayant une police d'assurance récente. Un score élevé représente donc un assuré en bas âge ayant une police récente et une prime élevé tandis qu'un score faible représente une personne plus âgée avec une faible prime d'assurance. 

La deuxième composante principale représente, quant à elle, l'âge du véhicule assuré. Un score élevé est associé à des véhicules de moindres valeurs mais risquant d'avantage un bris de veillesse. Plus les polices d'assurance sont récentes et plus le score en sera augmenté. Ainsi, les polices d'assurances récente ayant des véhicules de l'année représenteront les scores les plus faibles pour cette composante.

Pour ce qui est de la troisième composante principale, elle représente l'âge du véhicule, l'âge de l'assuré et l'âge de la police. Le score sera le plus élevé quand le véhicule est très vieux que l

Quand à la deuxième et à la sixième composante principale, c'est les variables *vehicl_age* et *vehicl_agepurchase* qui fournissent la plus grande contribution. Les variables explicatives *polholder_age* et *policy_age* ont les contributions les plus importantes pour les troisième et cinquième composantes principales. Pour ce qui est de la variable *policy_nbcontract*, elle est la variable apportant la plus grande contribution sur la quatrième composante principale. 

```{R , echo = FALSE, include = TRUE}
ACP$var$contrib
```

En illustrant les contributions des variables pour chacune des composantes principales, il est plus facile de visualiser les conclusions mentionnées précédemment.

```{R , message=FALSE, include = TRUE, echo = FALSE}
contrib <- data.frame(ACP$var$coord[,1:6])
contrib$carac <- rownames(contrib)
contrib.long <- reshape2::melt(contrib)

ggplot(contrib.long, aes(x=carac, fill=variable, y=value))+
  geom_bar(stat="identity",position=PositionDodge)+
  facet_grid(~variable)+
  theme(legend.position="top",axis.text.x = element_text(angle = 90))+
  coord_flip()
```

##Graphique présentant les résultats de l'ACP
CONCLUSIONS ??
```{R , echo = FALSE, include = TRUE}
data <- cbind(Donnees_tempo, ACP$ind$coord)

g_ind <- ggplot(data = data,
             aes(x= Dim.2, y=Dim.3, col = policy_age,  shape = lapse, labels = polholder_age,
                 alpha = 0.2)) +
  geom_point() +
  xlab("Dimension 2") +
  ylab("Dimension 3") +
  theme_bw()
ggplotly(g_ind) #Pour comparer les dimensions 2 et 3

g_ind <- ggplot(data = data,
             aes(x= Dim.1, y=Dim.2, col = vehicl_agepurchase,  shape = lapse, labels = prem_pure,
                 alpha = 0.2)) +
  geom_point() +
  xlab("Dimension 1") +
  ylab("Dimension 2") +
  theme_bw()
ggplotly(g_ind) #Pour comparer les dimensions 1 et 2

g_ind <- ggplot(data = data,
             aes(x= Dim.1, y=Dim.3, col = policy_age,  shape = lapse, labels = prem_pure,
                 alpha = 0.2)) +
  geom_point() +
  xlab("Dimension 1") +
  ylab("Dimension 3") +
  theme_bw()
ggplotly(g_ind) #Pour comparer les dimensions 1 et 3
```

À VÉRIFIER S'IL NE FAUT PAS INCLURE LES VARIABLES CATEGORIELLE ORDINALE TRANSFORMÉES EN VARIABLE NUMÉRQUES

\newpage

# Partitionnement en k moyennes

Le partitionnement en k moyennes est utiliser pour classifier les observations en k groupes distincts. La valeur de k est une valeur qu'on transmet pour indiquer le nombre de partitions désirées. Chaque observation sera ensuite assigné à un seul groupe. L'algorithme utilisée pour ce type de partitionnement a pour objectif de minimiser la variance intra-groupe.

```{R , echo = FALSE, include = TRUE}
Data_num <- Donnees_tempo[, c("polholder_age", "policy_age", "policy_nbcontract", "prem_final", "prem_last", "prem_market", 
                              "prem_pure", "vehicl_age", "vehicl_agepurchase")]

K <- 5
kmoyennes <- kmeans(Data_num, K, nstart=5)
Donnees_acp <- PCA(Data_num, scale = FALSE, ncp = 6, graph = FALSE)

composante1 <- Donnees_acp$ind$coord[,1]
composante2 <- Donnees_acp$ind$coord[,2]


groupe <- as.factor(kmoyennes$cluster)


ggplot() + geom_point(aes(composante1, composante2, color = groupe)) + theme_minimal()
```

\newpage

# Conclusion


\newpage

# Annexe

Notre jeu de données représente le statut de renouvellement pour 23 060 polices d'assurance basées sur un an d'observation. Les données receuillies proviennent d'une compagnie d'assurance inconnue dont l'année d'observation est également inconnue.
