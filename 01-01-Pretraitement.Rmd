---
header-includes: \usepackage[french]{babel} \usepackage{hyperref} \usepackage{booktabs} \hypersetup{ colorlinks=true,
  linkcolor=blue, filecolor=magenta, urlcolor=cyan, }
output:
  pdf_document: default
  html_document:
    df_print: paged
---

\newpage
\begin{flushright}
    \textbf{Équipe 8}
\end{flushright}

\begin{center}
    \vspace{2\baselineskip}
    Charles Comeau \\
    (111 185 421) \\
    \vspace{1\baselineskip}
    Nicholas Langevin \\
    (111 184 631) \\
    \vspace{1\baselineskip}
    Andréanne Larouche \\
    (111 190 518) \\
    \vspace{7\baselineskip}
    Apprentissage statistique en actuariat\\
    ACT-3114 \\
    \vspace{7\baselineskip}
    {\large
    \textbf{Analyse des données de renouvellement d'assurance}} \\
    \vspace{8\baselineskip}
    présenté à \\
    Marie-Pier Côté \\
    \vspace{9\baselineskip}
    École d’actuariat \\
    Université Laval \\
    27 février 2020
\end{center}

\newpage

\tableofcontents
```{R, LoadingPackages, echo = FALSE, include = FALSE, warning = FALSE}
library(CASdatasets)
library(knitr)
library(tidyverse)
library(mice)
library(xtable)
library(reshape2)
library(VIM)
library(gridExtra)
library(grid)
library(lattice)
require(FactoMineR)
require(factoextra)
require(plotly)
library(cluster)
```

```{R, TraitementDesDonnees, echo = FALSE, include = FALSE, warning = FALSE}
data(eudirectlapse)
data.init <- eudirectlapse

## Changement dans les donnees
data <- data.init

# Changement des 0 et 1 de lapse en renouvellement et resignation
data$lapse <- as.factor(data$lapse)
levels(data$lapse) <- c("renouvellement", "resignation")

# Changment des valeurs unknown en NA des variables: 
# polholder_diffdriver, vehicl_garage et policy_caruse
data[data$polholder_diffdriver == "unknown", ]$polholder_diffdriver <- NA
data[data$vehicl_garage == "unknown", ]$vehicl_garage <- NA
data[data$policy_caruse == "unknown", ]$policy_caruse <- NA

# Reordonnement de la variable prem_freqperyear en facteur ordonnée (ordinal)
data$prem_freqperyear <- factor(data$prem_freqperyear, order = TRUE, levels = c("1 per year", "2 per year", "4 per year", "12 per year"))

# Regions
data$vehicl_region <- factor(data$vehicl_region, order = TRUE, levels = c("Reg1", "Reg2", "Reg3", "Reg4", "Reg5", "Reg6", "Reg7", "Reg8", "Reg9", "Reg10", "Reg11", "Reg12", "Reg13", "Reg14"))

# Creation d un nouvelle variable prem_index=prem_final/prem_last
data$prem_index <- data$prem_final / data$prem_last - 1

# Traitement de la variable vehicl_powerkw: regroupement en 4 groupe
#data$vehicl_powerkw_na <- data$vehicl_powerkw
#data[data$vehicl_powerkw_na == "125-300 kW", ]$vehicl_powerkw_na <- NA
data[data$vehicl_powerkw %in% c("150 kW","175 kW","200 kW","225 kW","250 kW","275 kW","300 kW"), ]$vehicl_powerkw <- "125-300 kW"
data <- droplevels(data)
data$vehicl_powerkw <- factor(data$vehicl_powerkw, order = TRUE, levels = c("25-50 kW", "75 kW", "100 kW", "125-300 kW"))
table(data$vehicl_powerkw)

data
```

```{R, FonctionPrintTable, echo = FALSE, include = FALSE, warning = FALSE}

print.tables <- function(dat, caption="", label="", align=rep("c", ncol(dat)+1), digits=3, ...){
  print(xtable(dat, digits = digits,
             caption=caption,
             label=label,
             align=align),
            include.rownames = FALSE, sanitize.text.function=function(x){x},
            caption.placement = "top", comment=FALSE, ...)
}
```

\newpage

# Introduction

Les données qui seront analysées dans ce rapport proviennent du jeu de données "eudirectlapse" du paquetage "CASdatasets" de R. Dans le but de modéliser le statut de renouvellement d'une police d'assurance, représenté par la variable "lapse" dans ce cas-ci, il sera d'abord nécessaire de visualiser et de pré-traiter les données observées des 23 060 polices d'assurance. Il est à noter que la durée d'observation est de un an et que l'année visée et la compagnie demeurent inconnue. On pourra distincguer les statuts de renouvellement comme étant affiché à annulé("Cancellation") ou à renouvellement ("Renew") selon le cas approprié. 
Ce jeu de données est intéressant du fait qu'il permettera au fur de l'analyse de nous indiquer les variables types ayant un impact sur la décision de renouvellement de police des assurés d'une compagnie d'assurance X. En plus d'être un problème de nature actuarielle, le jeu de données choisi pourra nous permettre d'entammer une ouverture des réflexions possibles lorsque nous aurons à travailler dans une compagnie d'assurance. Étant trois personnes intéressés par l'assurance de dommages, ce problème nous semblait des plus appropriés et intéressant face à nos intérêts communs. Le nombre d'observations est également intéressant car il nous permettera de porter des conclusions précise avec assez de crédibilité sans toutefois être avoir à travailler avec un jeu de données inutilement trop volumineux. De plus, chaque variable explicative semble à prime à bord intéressante pour l'analyse et assez pertinente, ce que nous pourrons découvrir dans l'élaboration de ce travail pratique.

\newpage
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
# Analyse exploratoire des données

## Variable réponse
La variable lapse indique si l'assuré à renouveller ou non sa police lors du renouvellement. Il s'agit de la variable exogène. Initialement, le choix du client était indiqué par une variable binaire. Si le client désirait résigner sa police lapse prenait la valeur 1, autrement elle prenait la valeur 0. À des fins de simplification et pour que la visualisation en soit amiliorée pour la suite, nous avons converti la variable en variable catégorielle à deux niveaux. La variable prendra maintenant la valeur **`r levels(data$lapse)[2]`** si le client résigne sa police et de **`r levels(data$lapse)[1]`** s'il la renouvelle.

On constate qu'il y a `r nrow(data)` clients qui ont renouvelé alors qu'il y en a `r nrow(data[data$lapse == "renouvellement", ])` qui ont renouveller leur police d'assurance, se qui représente une proportion de `r round(nrow(data[data$lapse == "renouvellement",])/nrow(data)*100, 2)`%. La variable réponse n'est donc pas symétrique et il sera important d'en tenir compte lors de la modélisation. Pour mieux comprendre la cause de leur résignation et ainsi arriver à modéliser la variable de renouvellement de police, il sera nécessaire de faire l'analyse de variables explicatives contenus dans ce jeu de données. 

## Variables catégorielle

La variable **polholder_diffdriver** représente la différence de statut qui pourrait avoir entre le propriétaire de la police et le conducteur principale.

```{r tabl_statut, echo=FALSE, results='asis', fig.cap="\\label{tbl:statutdiff}Différence de statut"}
l1 <- c(summary(data$polholder_diffdriver)[c("all drivers > 24")])

l2 <- c(summary(data$polholder_diffdriver)[c("commercial")])

l3 <- c(summary(data$polholder_diffdriver)[c("learner 17")])

l4 <- c(summary(data$polholder_diffdriver)[c("only partner")])

l5 <- c(summary(data$polholder_diffdriver)[c("same")])

l6 <- c(summary(data$polholder_diffdriver)[c("young drivers")])

l7 <- c(summary(data$polholder_diffdriver)[c("NA's")])

ligne_name <- c("Conducteurs agée de 24+","Commerciale","Conducteur apprenti de 17 ans","Partenaire de couple", "Utilisateur seul", "Jeunes utilisateurs", "Données manquantes")
tableau_statut <- cbind(ligne_name ,rbind(l1 , l2, l3, l4, l5, l6, l7))

dat_frame_tab <- as.data.frame(tableau_statut)

colnames(dat_frame_tab) <- c("Statut", "Nombre d'observation")

print.tables(dat_frame_tab, hline.after=c(-1,0,7), digits=2, align = c("l", "l", "c"))
```

On constate que la plupart des voitures assurées est utilisée seulement par le détenteur de la police ou par l,assuré et son partenaire de couple puisque c'est deux cas représente `r round((summary(data$polholder_diffdriver)[c("only partner")] + summary(data$polholder_diffdriver)[c("same")])/nrow(data)*100, 2)`% des observations. Il y a un pourcentage non négligeable de `r round((summary(data$polholder_diffdriver)[c("young drivers")])/nrow(data)*100, 2)`% pour lequel le véhicules est partagé par de jeunes conducteurs alors qu'il y a `r summary(data$polholder_diffdriver)[c("all drivers > 24")]`% des cas ou le véhicule est plutôt partagé entre des personnes plus agées (24 ans et plus). À noté qu'il y a 12 observations pour lesquelles la variable est manquante. Cela sera traité dans la section traitement des valeurs manquantes. 


La variable **polholder_gender** représente le sexe du propriétaire de la police. Voici la répartition en pourcentage du sexe pour les propriétaires de police d'assurance.


```{r tabl_sexe, echo=FALSE, results='asis', fig.cap="\\label{tbl:sexeass}Sexe des assures"}
p1 <- c(round(summary(data$polholder_gender)[c("Male")]/nrow(data)*100, 2))

p2 <- c(round(summary(data$polholder_gender)[c("Female")]/nrow(data)*100, 2))

ligne_name <- c("Homme", "Femme")
tableau_sexe <- cbind(ligne_name ,rbind(p1 , p2))

dat_frame_tab2 <- as.data.frame(tableau_sexe)

colnames(dat_frame_tab2) <- c("Sexe", "\\%")

print.tables(dat_frame_tab2, hline.after=c(-1,0,2), digits=2)
```

On voit qu'il y a quand même significativement plus d'homme ayant une police d'assurance chez l'assureur que de femme. Possiblement pour la raison que les hommes conduise davantage une voiture.

La variable décrivant le travail du propriétaire du contrat est nommé **polholder_job**. Deux valeurs sont possibles soit "medical" soit "normal". On constate que `r round((summary(data$polholder_job)[c("medical")])/nrow(data)*100, 2)`% des assurés on un travail de type médical alors qu'il y en a `r round((summary(data$polholder_job)[c("normal")])/nrow(data)*100, 2)`% qui ont un autre type d'emploi.

La variable **policy_caruse** représente les fins d'utilisation du véhicule. 

```{r tabl_caruse, echo=FALSE, results='asis', fig.cap="\\label{tbl:caruse}Usage du vehicule"}
l1 <- c(summary(data$policy_caruse)[c("commercial")])

l2 <- c(summary(data$policy_caruse)[c("private or freelance work")])

l3 <- c(summary(data$policy_caruse)[c("NA's")])


ligne_name <- c("Commerciale","Privé ou aller travailler","Données manquantes")
tableau_caruse <- cbind(ligne_name ,rbind(l1 , l2, l3))

dat_frame_tab3 <- as.data.frame(tableau_caruse)

colnames(dat_frame_tab3) <- c("Usage", "Nombre d'observation")

print.tables(dat_frame_tab3, hline.after=c(-1,0,3), digits=2, align = c("l", "l", "c"))
```

On constate qu'il y a un nombre considérable de données manquantes et très peu de véhicule pour un usage commerciale.

De sont côté, **vehicl_garage** décrit le type de stationnement de la voiture. Voici la répartition des types de stationnement.

```{r tabl_garage, echo=FALSE, results='asis', fig.cap="\\label{tbl:garage}Type de stationnement"}
l1 <- c(summary(data$vehicl_garage)[c("carport")])

l2 <- c(summary(data$vehicl_garage)[c("parking deck")])

l3 <- c(summary(data$vehicl_garage)[c("private estate")])

l4 <- c(summary(data$vehicl_garage)[c("private garage")])

l5 <- c(summary(data$vehicl_garage)[c("street")])

l6 <- c(summary(data$vehicl_garage)[c("underground garage")])

l7 <- c(summary(data$vehicl_garage)[c("other")])

l8 <- c(summary(data$vehicl_garage)[c("NA's")])

ligne_name <- c("Sous un abri d'auto", "Terrase de stationnement", "Stationnement privé", "Garage", "Rue", "Garage sous-terrain", "Autre", "Données manquantes")
tableau_garage <- cbind(ligne_name ,rbind(l1 , l2, l3, l4, l5, l6, l7, l8))

dat_frame_tab4 <- as.data.frame(tableau_garage)

colnames(dat_frame_tab4) <- c("Moyen de stationnement", "Nombre d'observation")

print.tables(dat_frame_tab4, hline.after=c(-1,0,8), digits=2, align = c("l", "l", "c"))
```

On voit que pour les moyens de stationnement les plus populaire sont le garage privé et la rue. Il y a des données manquantes, elles seront traitées plus loin dans le rapport.

La variable polholder_BMCevol indique si la prime de renouvellement à connue une hausse, une baisse ou est demeuré stable par rapport à la prime payé lors du dernier renouvellement. Elle prend donc 3 valeurs possibles. 


```{r tabl_BM, echo=FALSE, results='asis', fig.cap="\\label{tbl:BM}Bonus Malus"}
l1 <- c(summary(data$polholder_BMCevol)[c("up")])

l2 <- c(summary(data$polholder_BMCevol)[c("stable")])

l3 <- c(summary(data$polholder_BMCevol)[c("down")])

ligne_name <- c("Hausse", "Inchangée", "Baisse")
tableau_BM <- cbind(ligne_name ,rbind(l1 , l2, l3))


ligne_name <- c("Sous un abri d'auto", "Terrase de stationnement", "Stationnement privé", "Garage", "Rue", "Garage sous-terrain", "Autre", "Données manquantes")
tableau_garage <- cbind(ligne_name ,rbind(l1 , l2, l3, l4, l5, l6, l7, l8))

dat_frame_tab4 <- as.data.frame(tableau_garage)

colnames(dat_frame_tab4) <- c("Moyen de stationnement", "Nombre d'observation")

print.tables(dat_frame_tab4, hline.after=c(-1,0,8), digits=2, align = c("l", "l", "c"))
```

On voit que pour les moyens de stationnement les plus populaire sont le garage privé et la rue. Il y a des données manquantes, elles seront traitées plus loin dans le rapport.

La variable polholder_BMCevol indique si la prime de renouvellement à connue une hausse, une baisse ou est demeuré stable par rapport à la prime payé lors du dernier renouvellement. Elle prend donc 3 valeurs possibles. 


```{r tabl_BM2, echo=FALSE, results='asis', fig.cap="\\label{tbl:BM}Bonus Malus"}
l1 <- c(summary(data$polholder_BMCevol)[c("up")])

l2 <- c(summary(data$polholder_BMCevol)[c("stable")])

l3 <- c(summary(data$polholder_BMCevol)[c("down")])

ligne_name <- c("Hausse", "Inchangée", "Baisse")
tableau_BM <- cbind(ligne_name ,rbind(l1 , l2, l3))

dat_frame_tab5 <- as.data.frame(tableau_BM)

colnames(dat_frame_tab5) <- c("Prime de renouvellement", "Nombre d'observation")

print.tables(dat_frame_tab5, hline.after=c(-1,0,3), digits=2, align = c("l", "l", "c"))
```

On constate que la plupart des contrats ont été inchangé ou ont connu des baisses au niveau des primes. (C'est un résultat étonnant, faudrait commenter la -dessus ???) 

La variable vehicl_region représente une région de l'union européenne. Il y a 14 régions, elles sont numérotés mais nous savons pas à quel emplacement géographique cela correspond. Voici un diagramme pour visualiser comment les contrats sont dsipersées dans chacune des régions.

```{r graph_vehicl_region, echo=FALSE, fig.width=5, fig.asp=.62, fig.align="center",fig.cap="\\label{fig:vehiclregion}Distribution des régions des détenteurs de police, représenté par la variable \\textbf{polholder\\_age}"}
ggplot(data, aes(x = vehicl_region))+
  geom_bar() +
  labs(x = "Région", y = "Fréquence") + 
  theme_bw() + theme(axis.text.x = element_text(angle = 20))
```

Les assurés sont répartis dans toutes les régions on note toutefois que la région 4 est la région pour laquelle il y a le plus d'assurés.


## Variable ordinal
La variable catégorielle ordinale **prem_freqperyear** représente la fréquence par année à laquelle la prime est payable. Les fréquence possible est mensuelle, trimestrielle, semestrielle ou annuelle.

```{r graph_prem_freqperyear, echo=FALSE, fig.width=5, fig.asp=.62, fig.align="center",fig.cap="\\label{fig:freqperyearAndvehiclGarage}todo"}
ggplot.premfreqperyear <- ggplot(data, aes(x = prem_freqperyear))+
  geom_bar() + theme_bw() + ggtitle("(1)") + theme(axis.text.x = element_text(angle = 90)) 
 

ggplot.vehicl_garage <- ggplot(data, aes(x = vehicl_garage))+
  geom_bar() + theme_bw() + ggtitle("(2)") + theme(axis.text.x = element_text(angle = 90)) 

grid.arrange(ggplot.premfreqperyear, ggplot.vehicl_garage,  ncol=2)
```
On voit qu'un peu moins de la moitié des clients paient la prime en un seul versement, environ un quart des clients paient trimestriellement, et le dernier quart est partagé par la prime payable semestriellement et mensuellement.


La variable **vehicl_powerkw** représente la puissance du moteur de la voiture conduit exprimé en chevaux moteurs. Initialement, cette variable contient 11 niveaux possibles. Cependant, en regardant les niveaux, nous avons constaté que les données pour cette variable n'ont pas été collectées uniformément puisque certaines catégories sont comprises dans une autre catégorie. Un des niveaux correspond aux véhicules d'une puissance se situant entre 125 et 300. Il y a aussi des groupes pour lequels la puissance se trouve entre l'interval du groupe présenté précédement, certains avec très peu d'observations d'autres avec un peu plus d'observations. Or, puisqu'on ne sait pas la puissance des voitures se trouvant dans le groupe de puissance 125-300 et que celui-ci comprend un grand nombre d'observation nous avons opté pour l'option d'ajouter les groupes pour lesquels leur puissance se situait entre 125 et 300 chevaux. Pour facilité la représentation du traitement effectué sur la variable **vehicl_powerkw** voici un tableau de fréquence avant traitement et tableau après traitement.


```{r tabl_powerkw, echo=FALSE, results='asis', fig.cap="\\label{tbl:powerkw}Tableaux de fréquence des catégories de puissance de moteur"}

c1_avant <- levels(data.init$vehicl_powerkw)
c2_avant <- unname(summary(data.init$vehicl_powerkw))

c1_apres <- levels(data$vehicl_powerkw)
c2_apres <- unname(summary(data$vehicl_powerkw))

tableau_powerkw_avant <- cbind(c1_avant, c2_avant)
tableau_powerkw_apres <- cbind(c1_apres, c2_apres)

tab_avant <- as.data.frame(tableau_powerkw_avant)
tab_apres <- as.data.frame(tableau_powerkw_apres)

colnames(tab_avant) <- c("Puissance", "Nombre d'observation")
colnames(tab_apres) <- c("Puissance", "Nombre d'observation")

t1 <- kable(tab_avant, format = "latex", align = c("c", "r"), booktabs = TRUE)
t2 <- kable(tab_apres, format = "latex", align = c("c", "r"),  booktabs = TRUE)

cat(c("\\begin{table}[!htb]
    \\begin{minipage}{.5\\linewidth}
      \\caption{}
      \\centering",
        t1,
    "\\end{minipage}%
    \\begin{minipage}{.5\\linewidth}
      \\centering
        \\caption{}",
        t2,
    "\\end{minipage} 
\\end{table}"
))  
```


## Variable numérique
La variable **polholder_age** est une variable numérique discrète représentant l'âge du propriétaire de la police d'assurance. La \autoref{fig:polholderAge} représente la distribution de âges des assurés.
```{r graph_polholder_age, echo=FALSE, fig.width=5, fig.asp=.62, fig.align="center",fig.cap="\\label{fig:polholderAge}Distribution de l'âge des détenteurs de polices dans la base de données, représenter par la variable \\textbf{polholder\\_age}"}
ggplot(data, aes(x = polholder_age))+
  geom_bar() +
  labs(x = "Âge du détenteur de police", y = "Fréquence") + 
  theme_bw() + facet_grid(~polholder_gender)
```
L'âge minimal parmis les assuré est de 19 ans et l'âge maximal est de 85 ans. On constate qu'il y a une forte proportion d'assuré entre 30 et 45 ans. Il pourra être pertinent d'analyser si les assurés de plus de 45 ans sont présent en moins grand nombre dû au fait que les primes sont trop élevé et font d'avantage d'appel pour comparer les primes ailleurs ce qui les mènent vers la résignation. 


Le nombre d'année sans résignation de la police d'assurance depuis la première année assurée est représenté par la variable umérique discrète **policy_age**. Avec l'aide de la \autoref{fig:policyAge} on constate une forte décroissance du nombre d'assurée pour le nombre d'années depuis l'entré en vigueur pour les 3 premières années pour ensuite ce stabilisé par la suite.
```{r graph_policy_age, echo=FALSE, fig.width=5, fig.asp=.62, fig.align="center",fig.cap="\\label{fig:policyAge}Distribution de l'âge pour laquelle une police est en vigeur, représenter par la variable \\textbf{policy\\_age}"}
ggplot(data, aes(x = policy_age))+
  geom_bar() +
  labs(x = "Âge de la police", y = "Fréquence") + 
  theme_bw() 

```


En ce qui concerne la variable discrète **policy_nbcontract** représentant le nombre de contrat, ou risque, que l'assuré possède chez l'assureur. L'histogramme illustré à la \autoref{fig:policyNbcontract} fait resortir le fait qu'il y a une forte concentration d'assuré pour lesquels le nombre de contrat qu'ils ont chez l'assureur est inférieur à 5. On peut aussi voir que certains assurés ont jusqu'à 15 contrats. 

```{r graph_policy_nbcontract, echo=FALSE, fig.width=5, fig.asp=.62, fig.align="center",fig.cap="\\label{fig:policyNbcontract}Distribution du nombre de contrats par police, représenter par la variable \\textbf{policy\\_nbcontract}"}
ggplot(data, aes(x = policy_nbcontract))+
  geom_bar() + 
  labs(x = "Nombre de contrat par police", y = "Fréquence") + 
  theme_bw() 
```


Il y a plusieurs variables numériques continues relatives à la prime. La variable **prem_final** représente le montant de la prime proposé pour le renouvellement par l'assureur alors que **prem_last** représente le montant payé lors du dernier renouvellement. La variable prem_market est la prime qui serait chargée selon le marché. La variable prem_pure est la prime qui représente les coûts espérés pour un assuré. Le \autoref{tbl:summaryPrimes} montre les distributions de chaqune des primes. Par contre, une prime seul peut difficilement expliquer pourquoi un assuré voudrais résigné car si l'assuré mérite réellement sa prime, il n'aurait pas intérêt à aller chez un concurant. Par contre, si lors de sont renouvellement, il voit sont montant d'assurance augmenter d'un grand poucentage, il serat tenté d'aller voir ayeur. C'est pourquoi la variable **prem_index** à été crée et ajouté à notre jeu de données. celle-ci représente le pourcentage d'augmentation de la prime, sois la prime final divisé par la prime du dernier terme.
```{r stats_prem, echo=FALSE, results='asis', fig.cap="\\label{tbl:summaryPrimes}Distribution des variables consernant les primes de l'assuré"}
stats_final <- c(summary(data$prem_final)[c(1, 3, 4, 6)], sd(data$prem_final))

stats_last <- c(summary(data$prem_last)[c(1, 3, 4, 6)], sd(data$prem_last))

stats_market <- c(summary(data$prem_market)[c(1, 3, 4, 6)], sd(data$prem_market))

stats_pure <- c(summary(data$prem_pure)[c(1, 3, 4, 6)], sd(data$prem_pure))

stats_index <- c(summary(data$prem_index)[c(1, 3, 4, 6)], sd(data$prem_index))

prime_type <- c("Final","Last","Market","Pure", "Index (\\%)")
tableau_stats <- cbind(prime_type ,rbind(round(stats_final, 2), round(stats_last, 2), round(stats_market, 2), round(stats_pure, 2), round(stats_index, 2)))

dat_frame_tab <- as.data.frame(tableau_stats)

colnames(dat_frame_tab) <- c("Prime (\\$)", "Minimum", "Médiane", "Moyenne", "Maximum", "Écart-type")

print.tables(dat_frame_tab, hline.after=c(-1,0,4,5), digits=2, align = c("l", "l", rep("c",5)))
```


Les deux prochaines variables sont en lien avec l'aĝe du véhicule, il s'agit de variables numériques discrètes. La variable vehicl_agepurchase représente l'âge du véhicule lorsque l'assuré a acheté le véhicule. La variable vehicl_age représente l'aĝe du véhicule actuellement. 

```{r graph_age, echo=FALSE, fig.width=5, fig.asp=.62, fig.align="center",fig.cap="\\label{fig:}todo"}
agepurchase_vehicule <- ggplot(data, aes(x = vehicl_agepurchase))+
  geom_bar() + theme_bw() + ggtitle("(1)") 

age_vehicule <- ggplot(data, aes(x = vehicl_age))+
  geom_bar()+ theme_bw() + ggtitle("(2)") 


grid.arrange(agepurchase_vehicule, age_vehicule,  ncol=2)

```

Beaucoup de véhicule ont été achetés lorsqu'il était neuf (vehicl_purchase = 0). En examinant les véhicules conduits par es assurés on remarque qu'il y a peu de véhicule neuf et le nombre de véhicule est croissant en fonction de l'utilisation jusqu'à 13 ans puis décroit par la suite. On retrouve un grand nombre de véhicule assuré avec 18 ans d'usage, il est fort probable que cela correspondre aux véhicules de plus de 18 ans. 



\newpage

# Traitement des valeurs manquantes
```{R, ProportionDeValeursManquante, echo = FALSE, results='asis'}
nb_manquant <- round(apply(data, 2, FUN = function(x) sum(is.na(x)))/nrow(data) * 100,2)
```
La base de données contenait seulement trois variables avec des valeurs manquante. La variable indiquant la difference d'âge entre le détenteur de police et le conducteur est manquante à `r nb_manquant[["polholder_diffdriver"]]`%, celle indiquant l'utilité du vehicule est manquante à `r nb_manquant[["policy_caruse"]]`% et la variable indiquant le type de garage où est entreposé le vehicule est manquante à `r nb_manquant[["vehicl_garage"]]`%. La \autoref{fig:missingPatern} montre le patron de non réponse. On remarque que la variable *polholder_diffdriver* semble avoir un patron de non réponse monotone avec les deux autres. Par contre, puisqu'il y a seulement 12 cas, nous allons pas tenir compte de ce lien lors de l'imputation des données. Pour ce qui est des variables *policy_caruse* et *vehicl_garage*, on remarque qu'il sont parfois manquante en même temps, mais seulement pour une minorité de cas.

```{R, MissingPattern, echo=FALSE, results="hide", fig.with=3, fig.height=3, fig.align="center", fig.cap="\\label{fig:missingPatern}todo"}
# pattern.matrix <- md.pattern(data, rotate.names = TRUE)
missing.pathern <- aggr(data, combined = TRUE, ylabs="",labels=c("","","","diffdriver","","","","caruse","","","","","","","","","garage","",""), sortVars=TRUE)
```

Premièrement, dans le but déterminer si le données manquantes sont MCAR, le test d'hypothese suivant à été effectué
\begin{align*}
  H_0:&\: \text{Le données sont MCAR} \\
  H_1:&\: \text{Le données ne sont pas MCAR}
\end{align*}
Pour conclure que les données sont MCAR, il est nécéssaire d'accepter $H_0$ pour toutes les variables. Par contre, un seul refus de cette hypothèse sera néséssaire permetra de conclure l'hypothèse alternative, c'est a dire que les données ne sont pas MCAR. Pour effectuer le test avec une variable catégorielle, il sera nécéssaire d'utilisé une statistique khi-carré alors que pour une variable numérique, une statistique student sera utilisée.

```{r TraitementDesValeursManquantes, echo=FALSE, results=FALSE}
test.MCAR <- function(var.data, na_var.data){
  # Détermine automatique si la variable est catégorielle ou
  # nuérique et utilise le bon test approprié.
  if(is.numeric(data[[var.data]])){
    round(t.test(data[[var.data]][is.na(data[[na_var.data]])],
                    data[[var.data]][!is.na(data[[na_var.data]])],var.equal=FALSE)[["p.value"]], 5) 
  }else{
    round(chisq.test(data[[var.data]], is.na(data[[na_var.data]]), correct=FALSE)[["p.value"]], 5)
  }
}
# Test pour vehicl_garage
sapply(names(data  %>% select(-vehicl_garage)), FUN=test.MCAR, na_var.data = "vehicl_garage")
# Test pour policy_caruse
sapply(names(data  %>% select(-policy_caruse)), FUN=test.MCAR, na_var.data = "policy_caruse")
# Test pour polholder_diffdriver
sapply(names(data  %>% select(-polholder_diffdriver, -vehicl_garage, -policy_caruse)), FUN=test.MCAR, na_var.data = "polholder_diffdriver")
```

En ce qui concerne les variables *vehicl_garage* et *policy_caruse*, plusieurs statistiques observé permette de rejeté l'hypothèse null en faveur de l'hypothèse alternative à un niveau significatif de $0.001%$. Par contre, dans le cas de *polholder_diffdriver*, seulement la variables *polholder_job* permet de rejeter $H_0$, c'est à dire que les données manquantes sont completement aléatoire.

Il est à noter qu'il n'est pas possible de vérifier avec certitude si les données sont MAR ou NMAR. Cela est dû au fait que puisque les données proviennent d'un compagnie inconnue, nous n'avons pas d'information sur la méthode de récolte de données et il nous est impossible de trouver des patrons qui pourraient provoquer des données de type NMAR. En conséquence, nous considérerons que nos données sont MAR. De ce sens, en effectuant des tests khi-carré pour la variable *polholder_diffdriver*, il a été remarqué que l'information sur la différence entre le détenteur de police et le conducteur nous indique que les variables sont toujours manquantes dans le cas ou le travail du détenteur de la police est dans le domaine de la médecine. Ceci renforce l'idée que le patrons de non réponse pour cette variable dépend des variables observés dans le jeux de données.

Pour l'imputation des données, la méthode d'imputation multiples à été choisie. Pour des restrictions de temps de calcul, cinq itérations de régression stochastique ont été fait. Pour la variable *policy_caruse*, une régression logistique a été effectué puisque la variable catégorielle comporte deux niveaux. Pour les variables *vehicl_garage* et *polholder_diffdriver*, qui sont des variables catégorielles non-ordonées, une régression polynomiale a été utilisée.

```{R, ImputationDesDonnees, echo = FALSE, eval=FALSE, warning = FALSE}
summary(data[,c("vehicl_garage", "policy_caruse", "polholder_diffdriver")])
# Choix des methode
methode <- c("sample","sample","polyreg","sample","sample","sample","logreg","sample","sample","sample","sample","sample","sample","sample","sample","polyreg","sample","sample", "sample")
donnees.imp <- mice(data %>% select(-lapse), m=1, method=methode, print=FALSE, seed=1095)
summary(donnees.imp)
data.compl <- mice::complete(donnees.imp)
data.compl <- cbind(data$lapse, data.compl)

# Summary apres semble similaire a avant
summary(data.compl[,c("vehicl_garage", "policy_caruse", "polholder_diffdriver")])
# Il ne reste bien plus de donnees.
apply(data.compl, 2, FUN = function(x) sum(is.na(x)))
```





\newpage

# Analyse en composantes principales
Étant donné que notre jeu de données contient `R nrow(Donnees_tempo)` observations, il peut être utile de visualiser les données à l'aide de l'analyse en composantes principales, appelé ACP. En effet, ce type d'analyse permet de mieux visualiser un jeu de données lorsque celui-ci est de grande dimension. Il sera ainsi possible de voir quelles variables explicatives sont plus intéressantes par leur impact sur la variance des composantes principales. Il est à noter qu'en général, on garde assez de composantes pour représenter entre 80 et 90 % de la variance totale. 

Pour que cette méthode de visualisation puisse être utilisée, il sera nécessaire de prendre seulement les variables explicatives numériques de ce jeu de donnée. Les variables catégorielles ne seront pas analysées dans cette section car même en les transformant en variables numériques, elles ne seront pas représentative des valeurs leur qui leur aurait été attribuée en faisant la modification de type.

```{R , echo = FALSE, include = TRUE}
data <- na.omit(data)
Data_num <- data[, c("polholder_age", "policy_age", "policy_nbcontract", "prem_final", "prem_last", "prem_market", 
                              "prem_pure", "vehicl_age", "vehicl_agepurchase")]
```

On doit ensuite choisir le nombre de composantes principales. Cette étape peut être complétée en ayant deja un pourcentage de variance expliquée en tête et en choisissant le nombre de composantes à partir des valeurs propres ou en analysant directement le diagramme d'ébouli. Dans ce cas, la méthode du coude ne sera pas utilisée, on priviligie d'avantage le choix selon le premier plateau observée. Le nombre de composantes choisit seront celle ne faisant pas partie du premier plateau observée. 

```{R , echo = FALSE, include = FALSE}
ACP <- PCA(Data_num, scale = TRUE)  
```

```{R , echo = FALSE, include = TRUE}
fviz_screeplot(ACP)
```

Selon le diagramme d'éboulis, il sera nécessaire de conserver 2 composantes principales et on observe, à l'aide des valeurs propres de la matrice de corélation, que 2 composantes principales permettent d'expliquer 63% de la variance totale.

À l'aide du graphique ACP des variables, on peut voir la gravité des contributions pour chacune des variables sur chaque composantes principales retenu. Ainsi, on peut observer que pour la première composante principale, un score élevé indique un contrat ayant une prime élevée, que ce soit la prime du marché, la prime pure, la prime finale ou la prime chargée lors du dernier renouvellement. Par contre, un assuré âgé qui renouvelle depuis plusieurs année aura un score plus faible qu'un assuré en bas âge ayant une police d'assurance récente. Un score élevé représente donc un assuré en bas âge ayant une police récente et une prime élevé tandis qu'un score faible représente une personne plus âgée avec une faible prime d'assurance. 

La deuxième composante principale représente, quant à elle, l'âge du véhicule assuré. Un score élevé est associé à des véhicules de moindres valeurs mais risquant d'avantage un bris de veillesse. Plus les polices d'assurance sont récentes et plus le score en sera augmenté. Ainsi, les polices d'assurances récente ayant des véhicules de l'année représenteront les scores les plus faibles pour cette composante.

```{R , echo = FALSE, include = FALSE}
ACP$eig
ACP$var$contrib
```

En illustrant les contributions des variables pour les deux premières composantes principales, il est plus facile de visualiser les conclusions mentionnées précédemment.

```{R , message=FALSE, include = TRUE, echo = FALSE}
contrib <- data.frame(ACP$var$coord[,1:2])
contrib$carac <- rownames(contrib)
contrib.long <- reshape2::melt(contrib)

ggplot(contrib.long, aes(x=carac, fill=variable, y=value))+
  geom_bar(stat="identity",position=PositionDodge)+
  facet_grid(~variable)+
  theme(legend.position="top",axis.text.x = element_text(angle = 90))+
  xlab("Variable") +
  ylab("Poids") +
  coord_flip()
```

\newpage

# Partitionnement en k moyennes

Le partitionnement en k moyennes est utilisé pour classifier les observations en k groupes distincts. La valeur de k est une valeur qu'on transmet pour indiquer le nombre de partitions désirées. Chaque observation sera ensuite assigné à un seul groupe. L'algorithme utilisée pour ce type de partitionnement a pour objectif de minimiser la variance intra-groupe.

Le choix du nombre de groupe peut être choisit à l'aide du diagramme d'éboulis par la méthode du coude. Ainsi en ce réferant au graphique YYY de la section "Analyse en composantes principales", on devrait faire le partitionnement sur 6 groupes distincts. En effet le choix s'effectue pour que le nombre de composantes apporte individuellement un pourcentage de variance expliquée significatif. On s'arrête sur la composante principale qui ce situe dans le "pli de coude", soit juste avant le dernier plateau.

Voici le graphique obtenu pour le partitionnement en $k$ moyennes :
```{R , echo = FALSE, include = TRUE}
K <- 6
kmoyennes <- kmeans(Data_num, K, nstart=5)
Donnees_acp <- PCA(Data_num, ncp = 6,  scale = FALSE, graph = FALSE)

composante1 <- Donnees_acp$ind$coord[,1]
composante2 <- Donnees_acp$ind$coord[,2]

groupe <- as.factor(kmoyennes$cluster)

ggplot() + 
  geom_point(aes(composante1, composante2, color = groupe)) + 
  theme_minimal()
```

De ce graphique, on peut conclure que le partionnement c'est fait vraiment que sur les montants des primes. 

\newpage

# Conclusion


\newpage

# Bibliographie


\newpage

# Annexe

Description du jeu de données soumis sur le forum :

Notre jeu de données représente le statut de renouvellement pour 23 060 polices d'assurance basées sur un an d'observation. Les données receuillies proviennent d'une compagnie d'assurance inconnue dont l'année d'observation est également inconnue.
